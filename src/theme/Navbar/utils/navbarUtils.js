/**
 * Removes the base URL and the leading slash from a given path.
 *
 * @param {string} path - The path to normalize.
 * @returns {string} - The normalized path.
 */
export function normalizePath(path, routeBasePath) {
  if (routeBasePath && path.startsWith(routeBasePath)) {
    path = path.slice(routeBasePath.length);
  }
  return path.startsWith("/") ? path.slice(1) : path;
}

/**
 * Recursively searches for the currentPath in an array of sidebar items.
 *
 * @param {Array} items - The sidebar items.
 * @param {string} currentPath - The path to match.
 * @returns {boolean} - True if the path is found; otherwise, false.
 */
export function findPathInItems(items, currentPath) {
  for (const item of items) {
    if (typeof item === "string") {
      if (item.startsWith(currentPath)) {
        return true;
      }
    } else if (item.type === "doc") {
      if (isPathMatch(item.id, currentPath)) {
        return true;
      }
    } else if (item.type === "autogenerated") {
      if (currentPath.startsWith(item.dirName)) return true;
    } else if (item.type === "category") {
      // Optionally check the category's link if it exists.
      if (
        item.link &&
        item.link.type === "doc" &&
        isPathMatch(item.link.id, currentPath)
      ) {
        return true;
      }
      // Recursively search for the currentPath in the category items.
      if (
        Array.isArray(item.items) &&
        findPathInItems(item.items, currentPath)
      ) {
        return true;
      }
    }
  }
  return false;
}

/**
 * Helper function to check if two paths match precisely
 * This prevents false matches like "cloud" matching "weaviate-cloud"
 *
 * @param {string} itemId - The item ID to check
 * @param {string} currentPath - The current path
 * @returns {boolean} - True if paths match
 */
function isPathMatch(itemId, currentPath) {
  // Split paths into segments
  const itemSegments = itemId.split("/");
  const currentSegments = currentPath.split("/");

  // For exact matches
  if (itemId === currentPath) {
    return true;
  }

  // Check if currentPath is a prefix of itemId (for nested routes)
  if (itemId.startsWith(currentPath)) {
    return true;
  }

  // Check if the first segment matches exactly (for top-level sections)
  if (currentSegments.length === 1 && itemSegments.length >= 1) {
    return itemSegments[0] === currentSegments[0];
  }

  // For multi-segment paths, check if current path is a prefix
  if (currentSegments.length <= itemSegments.length) {
    return currentSegments.every(
      (segment, index) => segment === itemSegments[index]
    );
  }

  return false;
}

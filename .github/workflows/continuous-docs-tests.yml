name: CI for testing-ci branch

on:
  push:
    branches:
      - testing-ci
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Free up disk space by removing unnecessary software
      - name: Free disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf /usr/local/share/boost
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"
          docker system prune -af
          docker volume prune -f
          df -h

      # Make scripts executable
      - name: Make scripts executable
        run: |
          chmod +x tests/start-weaviate.sh
          chmod +x tests/stop-weaviate.sh

      # Set up Python BEFORE Docker operations to reduce memory pressure
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      # Cache pip dependencies
      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      # Cache virtual environment
      - name: Cache virtual environment
        uses: actions/cache@v4
        id: cache-venv
        with:
          path: .venv
          key: ${{ runner.os }}-venv-${{ runner.arch }}-python3.10-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-venv-${{ runner.arch }}-python3.10-

      - name: Create virtual environment and install dependencies
        if: steps.cache-venv.outputs.cache-hit != 'true'
        run: |
          python -m venv .venv
          source .venv/bin/activate
          pip install --upgrade pip
          pip install -r tests/requirements.txt

      - name: Verify cached virtual environment
        if: steps.cache-venv.outputs.cache-hit == 'true'
        run: |
          source .venv/bin/activate
          python --version
          pip list

      # Cache Docker images
      - name: Cache Docker images
        uses: actions/cache@v4
        id: cache-docker-images
        with:
          path: /tmp/docker-images.tar
          key: ${{ runner.os }}-docker-images-${{ hashFiles('tests/docker-compose*.yml') }}
          restore-keys: |
            ${{ runner.os }}-docker-images-

      # Load cached Docker images or pull new ones
      - name: Load or pull Docker images
        run: |
          if [[ "${{ steps.cache-docker-images.outputs.cache-hit }}" == "true" ]]; then
            echo "Cache hit. Loading Docker images from cache."
            docker load --input /tmp/docker-images.tar
          else
            echo "Cache miss. Pulling images and saving to cache."
            echo "Pulling images selectively to save disk space..."
            
            # Pull all images first
            for file in tests/docker-compose*.yml; do
              if [ -f "$file" ]; then
                echo "Pulling images from $file"
                docker compose -f "$file" pull
                docker system prune -f
              fi
            done
            
            # Save images to cache
            echo "Saving images to cache..."
            # Get all unique image names from compose files
            images=""
            for file in tests/docker-compose*.yml; do
              if [ -f "$file" ]; then
                file_images=$(docker compose -f "$file" config --images 2>/dev/null || true)
                images="$images $file_images"
              fi
            done
            
            # Remove duplicates and save
            unique_images=$(echo $images | tr ' ' '\n' | sort -u | tr '\n' ' ' | xargs)
            if [[ -n "$unique_images" ]]; then
              echo "Saving images to cache: $unique_images"
              docker save $unique_images -o /tmp/docker-images.tar
            fi
          fi

          # Clean up after loading/pulling
          docker system prune -f
          df -h

      # Start Docker containers
      - name: Start Weaviate containers
        run: |
          echo "Starting Weaviate Docker containers..."
          ./tests/start-weaviate.sh
          echo "Waiting for containers to be ready..."
          sleep 30
          echo "Container status:"
          docker ps

      # Wait for services to be ready
      - name: Wait for Weaviate services
        run: |
          echo "Checking if Weaviate services are ready..."
          # List of ports to check based on your docker-compose files
          ports=(8099 8580 8080 8090 8280 8180 8181 8182)

          for port in "${ports[@]}"; do
            echo "Checking port $port..."
            timeout=120  # 2 minutes timeout per service
            count=0
            
            while [ $count -lt $timeout ]; do
              if curl -sf "http://localhost:$port/v1/.well-known/ready" >/dev/null 2>&1; then
                echo "✅ Service on port $port is ready"
                break
              fi
              
              if [ $((count % 10)) -eq 0 ]; then
                echo "⏳ Waiting for service on port $port... (${count}s elapsed)"
              fi
              
              sleep 1
              count=$((count + 1))
            done
            
            if [ $count -ge $timeout ]; then
              echo "⚠️ Service on port $port not ready after ${timeout}s, continuing..."
            fi
          done

          echo "Service readiness check completed"

      - name: Run tests
        env:
          GITHUB_ENV: "true" # Tell conftest.py that GitHub Actions is managing Docker
          WEAVIATE_URL: ${{ secrets.WEAVIATE_URL }}
          WEAVIATE_HOST: ${{ secrets.WEAVIATE_HOST }}
          WEAVIATE_HOSTNAME: ${{ secrets.WEAVIATE_HOSTNAME }}
          WEAVIATE_HTTP_HOST: ${{ secrets.WEAVIATE_HTTP_HOST }}
          WEAVIATE_GRPC_HOST: ${{ secrets.WEAVIATE_GRPC_HOST }}
          WEAVIATE_API_KEY: ${{ secrets.WEAVIATE_API_KEY }}
          WEAVIATE_LOCAL_API_KEY: ${{ secrets.WEAVIATE_LOCAL_API_KEY }}
          COHERE_API_KEY: ${{ secrets.COHERE_API_KEY }}
          COHERE_APIKEY: ${{ secrets.COHERE_APIKEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_APIKEY: ${{ secrets.OPENAI_APIKEY }}
          HUGGINGFACE_APIKEY: ${{ secrets.HUGGINGFACE_APIKEY }}
          ANTHROPIC_APIKEY: ${{ secrets.ANTHROPIC_APIKEY }}
          WCD_USERNAME: ${{ secrets.WCD_USERNAME }}
          WCD_PASSWORD: ${{ secrets.WCD_PASSWORD }}
        run: |
          source .venv/bin/activate
          pytest -m pyv4 -v -s tests/test_compression.py

      # Clean up containers
      - name: Stop Weaviate containers
        if: always()
        run: |
          echo "Stopping Weaviate Docker containers..."
          ./tests/stop-weaviate.sh || true

      - name: Final cleanup
        if: always()
        run: |
          echo "Final cleanup of Docker resources..."
          for file in tests/docker-compose*.yml; do
            if [ -f "$file" ]; then
              echo "Ensuring $file services are stopped"
              docker compose -f "$file" down -v || true
            fi
          done
          docker system prune -af || true

---
title: Migrating between vectorizers
description: Learn two approaches to migrate from one vectorizer to another in Weaviate without service interruption
sidebar_position: 4
image: og/docs/tutorials.jpg
# tags: ['migration', 'vectorizers', 'embeddings', 'named-vectors', 'aliases']
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import FilteredTextBlock from "@site/src/components/Documentation/FilteredTextBlock";
import PyCode from "!!raw-loader!/docs/weaviate/tutorials/_includes/vectorizer-migration.py";

# Migrating vectorizers in Weaviate

In this tutorial, we'll explore two powerful approaches to migrate from one vectorizer (embedding model) to another in Weaviate without service interruption. Whether you're upgrading to a better model, reducing costs, or switching providers, these methods ensure smooth transitions.

## prerequisites

Before starting this tutorial, ensure you have:

- A Weaviate Cloud instance (version `v1.32` or newer)
- Python 3.8+ installed
- Required Python packages installed:
  ```bash
  pip install weaviate-client datasets
  ```
- Environment variables set for your Weaviate credentials:
  ```bash
  export WEAVIATE_URL="your-weaviate-cloud-url"
  export WEAVIATE_API_KEY="your-api-key"
  ```
- Basic familiarity with Weaviate collections and vector search

:::tip Get Started with Weaviate Cloud
Sign up for a free Weaviate Cloud sandbox at [console.weaviate.cloud](https://console.weaviate.cloud)
:::

## introduction

When working with vector databases in production, you may need to change your embedding model for various reasons:

- **Performance improvements**: Newer models often provide better search accuracy
- **Cost optimization**: Different models have different pricing structures
- **Provider changes**: Switching between OpenAI, Cohere, Weaviate Embeddings, etc.
- **Model deprecation**: When a model you're using is being retired

This tutorial demonstrates two approaches:

### method 1: named vectors (in-place migration)

Named vectors allow multiple vector representations within the same collection. This method is ideal when you want to:

- Test new models alongside existing ones
- Gradually transition between models
- Keep all data in one collection

### method 2: collection aliases (blue-green deployment)

Collection aliases enable instant switching between collections. This method is perfect when you want to:

- Completely replace the vectorizer
- Ensure rollback capability
- Minimize risk during migration

## setup: ecommerce dataset

We'll use the Weaviate ECommerce dataset from Hugging Face, which contains clothing items with pre-computed embeddings. This dataset represents a real-world scenario where you have existing vector embeddings that need migration.

First, install the required dependencies:

```bash
pip install weaviate-client datasets
```

The dataset includes:

- Product information (name, description, category, price, brand, etc.)
- Pre-computed 768-dimensional vectors
- Over 1000 clothing items with detailed metadata

<FilteredTextBlock
  text={PyCode}
  startMarker="# START ImportEcommerceData"
  endMarker="# END ImportEcommerceData"
  language="py"
/>

## step 1: connect to weaviate cloud

First, establish a connection to your Weaviate Cloud instance:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1Connect"
  endMarker="# END Method1Connect"
  language="py"
/>

## step 2: create a collection

Create a collection that accepts self-provided vectors (your existing embeddings from the HuggingFace dataset):

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1CreateCollection"
  endMarker="# END Method1CreateCollection"
  language="py"
/>

## step 3: import data

Import your ecommerce data along with the pre-computed vectors:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1ImportData"
  endMarker="# END Method1ImportData"
  language="py"
/>

## step 4: query with original vectors

Verify that searches work with your original vectors:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1QueryOriginal"
  endMarker="# END Method1QueryOriginal"
  language="py"
/>

## method 1: add new vector

Named vectors allow you to have multiple vector representations in the same collection. This enables gradual migration and A/B testing of different models.

### step 5: add new vector with Weaviate Embeddings

Add a second named vector using Weaviate's built-in embeddings model:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1AddNewVector"
  endMarker="# END Method1AddNewVector"
  language="py"
/>

### step 6: trigger vectorization

Update all objects to generate embeddings with the new vectorizer. We use a minimal update that doesn't change properties:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1TriggerVectorization"
  endMarker="# END Method1TriggerVectorization"
  language="py"
/>

### step 7: query with new vector

Now you can query using either vector:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1QueryNewVector"
  endMarker="# END Method1QueryNewVector"
  language="py"
/>

### advantages of named vectors method

- **Gradual migration**: Test new embeddings without affecting existing functionality
- **A/B testing**: Compare search quality between models
- **Single collection**: All data remains in one place
- **Flexible queries**: Choose which vector to use at query time

## method 2: collection aliases migration

Collection aliases provide a blue-green deployment approach, allowing instant switching between collections with different vectorizers.

### step 5: create collection alias and query using alias

Create an alias that your application will use:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method2CreateAlias"
  endMarker="# END Method2CreateAlias"
  language="py"
/>

Your application should always use the alias:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method2QueryAlias"
  endMarker="# END Method2QueryAlias"
  language="py"
/>

### step 6: create new collection with Weaviate Embeddings

Create a new collection using the Weaviate Embeddings vectorizer:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method2CreateNew"
  endMarker="# END Method2CreateNew"
  language="py"
/>

### step 7: migrate data to new collection

Copy data to the new collection (vectors will be auto-generated):

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method2MigrateData"
  endMarker="# END Method2MigrateData"
  language="py"
/>

### step 8: switch the alias and query using alias

Update the alias to point to the new collection (instant switch):

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method2SwitchAlias"
  endMarker="# END Method2SwitchAlias"
  language="py"
/>

After verification, remove the old collection:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method2Cleanup"
  endMarker="# END Method2Cleanup"
  language="py"
/>

### advantages of collection aliases method

- **Instant switching**: Zero-downtime migration
- **Easy rollback**: Switch back to old collection if issues arise
- **Clean separation**: Old and new data are completely isolated
- **No code changes**: Application continues using the same alias

## choosing the right method and performance considerations

### use named vectors when:

- You want to **test multiple models** simultaneously
- You need **gradual migration** with side-by-side comparison
- You prefer keeping **all data in one collection**
- You want to **experiment** with different search strategies
- **Storage**: Each additional vector increases storage requirements
- **Query performance**: Minimal overhead when selecting specific vectors
- **Migration time**: Depends on update speed for triggering vectorization

### use collection aliases when:

- You need **instant, atomic switches** between models
- You want **guaranteed rollback** capability
- You prefer **complete isolation** between old and new setups
- You're doing a **one-time migration** to a new model
- **Storage**: Temporary duplication during migration
- **Query performance**: No overhead - aliases are simple pointers
- **Migration time**: Depends on data copy speed

## best practices

1. **Test thoroughly**: Always test the new vectorizer with a subset of data first
2. **Monitor quality**: Compare search results between old and new models
3. **Plan for rollback**: Keep the old setup available until you're confident
4. **Consider costs**: Different vectorizers have different pricing models
5. **Document changes**: Track which model versions you're using

## complete example: production migration

Here's a complete example showing a production-ready migration workflow:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START ProductionExample"
  endMarker="# END ProductionExample"
  language="py"
/>

## troubleshooting

### common issues and solutions

**Issue**: Vectorization fails for some objects
**Solution**: Check for empty or invalid text fields, ensure the vectorizer supports your data format

**Issue**: Search quality degrades after migration
**Solution**: Compare embedding dimensions, consider fine-tuning or trying different models

**Issue**: Migration is too slow
**Solution**: Use batch operations, parallelize updates, consider off-peak migration

## summary

This tutorial demonstrated two powerful approaches for migrating vectorizers in Weaviate:

- **Named Vectors**: Best for gradual migration and testing multiple models
- **Collection Aliases**: Best for instant switching and blue-green deployments

Both methods ensure zero downtime and provide rollback capabilities, making them suitable for production environments.

## running the code

To run this tutorial:

1. Set up your environment variables:

   ```bash
   export WEAVIATE_URL="your-weaviate-cloud-url"
   export WEAVIATE_API_KEY="your-api-key"
   ```

2. Install dependencies:

   ```bash
   pip install weaviate-client datasets
   ```

3. Run either migration method from the Python scripts provided

The code will automatically load the ECommerce dataset from Hugging Face and demonstrate both migration approaches.

## further resources

- [Collection Aliases Reference](../manage-collections/collection-aliases.mdx)

## questions and feedback

import DocsFeedback from "/_includes/docs-feedback.mdx";

<DocsFeedback />

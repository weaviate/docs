---
title: Migrating between vectorizers
description: Learn two approaches to migrate from one vectorizer to another in Weaviate without service interruption
sidebar_position: 4
image: og/docs/tutorials.jpg
# tags: ['migration', 'vectorizers', 'embeddings', 'named-vectors', 'aliases']
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import FilteredTextBlock from "@site/src/components/Documentation/FilteredTextBlock";
import PyCode from "!!raw-loader!/docs/weaviate/tutorials/_includes/vectorizer-migration.py";

# Migrating vectorizers in Weaviate

In this tutorial, we'll explore two powerful approaches to migrate from one vectorizer (embedding model) to another in Weaviate without service interruption. Whether you're upgrading to a better model, reducing costs, or switching providers, these methods ensure smooth transitions.

## Prerequisites

Before starting this tutorial, ensure you have:

- A Weaviate Cloud instance (version `v1.32` or newer)
- Python 3.8+ installed
- Required Python packages installed:
  ```bash
  pip install weaviate-client datasets
  ```
- Environment variables set for your Weaviate credentials:
  ```bash
  export WEAVIATE_URL="your-weaviate-cloud-url"
  export WEAVIATE_API_KEY="your-api-key"
  ```
- Basic familiarity with Weaviate collections and vector search

:::tip Get Started with Weaviate Cloud

Sign up for a free Weaviate Cloud sandbox at [console.weaviate.cloud](https://console.weaviate.cloud)

:::

## Introduction

When working with vector databases in production, you may need to change your embedding model for various reasons:

- **Performance improvements**: Newer models often provide better search accuracy
- **Cost optimization**: Different models have different pricing structures
- **Provider changes**: Switching between OpenAI, Cohere, Weaviate Embeddings, etc.
- **Model deprecation**: When a model you're using is being retired

This tutorial demonstrates two approaches:

- **Adding new vectors**
  This method allows multiple vectors per data object within a single collection. It's ideal for testing new models alongside existing ones and keeping all the data in one collection.
- **Collection aliases**
  This approach uses aliases to instantly switch between separate collections. It's perfect for a complete model replacement, minimizing risk and providing an immediate rollback option.

## Step 1: Connect to Weaviate Cloud

First, establish a connection to your Weaviate Cloud instance:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1Connect"
  endMarker="# END Method1Connect"
  language="py"
/>

## Step 2: Create a collection

Create a collection that accepts self-provided vectors (your existing embeddings from the HuggingFace dataset):

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1CreateCollection"
  endMarker="# END Method1CreateCollection"
  language="py"
/>

## Step 3: Import data

We'll use the Weaviate ECommerce dataset from Hugging Face, which contains clothing items with pre-computed embeddings. This dataset represents a real-world scenario where you have existing vector embeddings that need migration.

The dataset includes:

- Product information (name, description, category, price, brand, etc.)
- Pre-computed 768-dimensional vectors

<FilteredTextBlock
  text={PyCode}
  startMarker="# START ImportEcommerceData"
  endMarker="# END ImportEcommerceData"
  language="py"
/>

Import your e-commerce data along with the pre-computed vectors:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1ImportData"
  endMarker="# END Method1ImportData"
  language="py"
/>

## Step 4: Query with original vectors

Verify that searches work with your original vectors:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1QueryOriginal"
  endMarker="# END Method1QueryOriginal"
  language="py"
/>

## Method 1: Add new vector

Named vectors allow you to have multiple vector representations in the same collection. This enables gradual migration and A/B testing of different models.

### Step 5: Add new vector with Weaviate Embeddings

Add a second named vector using Weaviate's built-in embeddings model:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1AddNewVector"
  endMarker="# END Method1AddNewVector"
  language="py"
/>

### Step 6: Trigger vectorization

Update all objects to generate embeddings with the new vectorizer. We use a minimal update that doesn't change properties:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1TriggerVectorization"
  endMarker="# END Method1TriggerVectorization"
  language="py"
/>

### Step 7: Query with new vector

Now you can query using either vector:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method1QueryNewVector"
  endMarker="# END Method1QueryNewVector"
  language="py"
/>

## Method 2: Collection aliases migration

Collection aliases provide a blue-green deployment approach, allowing instant switching between collections with different vectorizers.

### Step 5: Create collection alias and query using alias

Create an alias that your application will use:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method2CreateAlias"
  endMarker="# END Method2CreateAlias"
  language="py"
/>

Your application should always use the alias:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method2QueryAlias"
  endMarker="# END Method2QueryAlias"
  language="py"
/>

### Step 6: Create new collection with Weaviate Embeddings

Create a new collection using the Weaviate Embeddings vectorizer:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method2CreateNew"
  endMarker="# END Method2CreateNew"
  language="py"
/>

### Step 7: Migrate data to new collection

Copy data to the new collection (vectors will be auto-generated):

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method2MigrateData"
  endMarker="# END Method2MigrateData"
  language="py"
/>

### Step 8: Switch the alias and query using alias

Update the alias to point to the new collection (instant switch):

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method2SwitchAlias"
  endMarker="# END Method2SwitchAlias"
  language="py"
/>

After verification, remove the old collection:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START Method2Cleanup"
  endMarker="# END Method2Cleanup"
  language="py"
/>

## Choosing the right method

Use **new vectors** when:

- You want to **test multiple models** simultaneously
- You prefer keeping **all data in one collection**
- You want to **experiment** with different search strategies

Use **collection aliases** when:

- You want **rollback** capability
- You prefer **complete isolation** between old and new setups
- You're doing a **one-time migration** to a new model

## Best practices

1. **Test thoroughly**: Always test the new vectorizer with a subset of data first
2. **Monitor quality**: Compare search results between old and new models
3. **Plan for rollback**: Keep the old setup available until you're confident
4. **Consider costs**: Different vectorizers have different pricing models
5. **Document changes**: Track which model versions you're using

## Production migration example

Here's a complete example showing a production-ready migration workflow:

<FilteredTextBlock
  text={PyCode}
  startMarker="# START ProductionExample"
  endMarker="# END ProductionExample"
  language="py"
/>

## Summary

This tutorial demonstrated two powerful approaches for migrating vectorizers in Weaviate:

- **Named Vectors**: Best for gradual migration and testing multiple models
- **Collection Aliases**: Best for instant switching and blue-green deployments

Both methods ensure zero downtime and provide rollback capabilities, making them suitable for production environments.

## Further resources

- [Collection Aliases Reference](../manage-collections/collection-aliases.mdx)

## Questions and feedback

import DocsFeedback from "/_includes/docs-feedback.mdx";

<DocsFeedback />

---
title: "ベクトルインデックス：概要"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import FilteredTextBlock from '@site/src/components/Documentation/FilteredTextBlock';
import PyCode from '!!raw-loader!./_snippets/100_config.py';

データベースインデックスとは、検索を効率化するためにデータを整理するデータ構造です。本の目次や図書館の索引のように、必要な情報を素早く見つけられるようにします。

<div class="academy-img-md">
  <img
    src="https://upload.wikimedia.org/wikipedia/commons/3/32/Card_catalog_from_page_167_of_%22Manual_of_library_classification_and_shelf_arrangement%22_%281898%29.jpg"
    alt="Card catalog from page 167 of 'Manual of library classification and shelf arrangement' (1898)"
  />
</div>

[ベクトルインデックス](/weaviate/concepts/indexing/vector-index.md) は、ベクトルを保存し検索するために特化したインデックスです。

ベクトルインデックスの選択と設定は、インポートや検索のパフォーマンス、そして Weaviate インスタンスのリソース要件に大きく影響します。

そのため、ベクトルインデックスは Weaviate における重要なコンポーネントです。

## <i class="fa-solid fa-square-chevron-right"></i> ベクトルインデックスの利点

データベースは急速に巨大化するため、特定の項目を検索する時間が許容できないほど長くなったり、検索に必要なリソースが過剰になったりすることがあります。

ベクトルインデックスは、大規模データベースでの検索体験を向上させるために設計されています。

通常、検索速度・精度・リソース要件という 3 つの要素をバランスするためにトレードオフを行います。

## <i class="fa-solid fa-square-chevron-right"></i> ベクトルインデックスの種類

ベクトルインデックスには多くの種類があります。大半は比較すべきベクトル数を減らすことで検索を高速化しますが、その手法はさまざまで、それぞれに長所と短所があります。

### <i class="fa-solid fa-chalkboard"></i> グラフインデックス

グラフインデックスはベクトル間にネットワークを形成し、類似したベクトル同士を接続します。これにより、クエリベクトルに近いベクトルをグラフ上で高速に「トラバース」して見つけられます。

import HNSWDiagram from './_snippets/hnsw_diagram.png';

<div class="academy-img-md">
  <img src={HNSWDiagram} alt="Outline of HNSW graph, showing nodes connected in multiple layers"/>
</div>

HNSW（Hierarchical Navigable Small World）は、最も一般的なグラフインデックスタイプです。複数の「レイヤー」にベクトルを配置し、グラフを高速に横断できるようにします。

HNSW はスケーラビリティに優れ、インクリメンタル更新が可能で、高次元ベクトルにも効率的です。

これは Weaviate のデフォルトインデックスタイプです。

### <i class="fa-solid fa-chalkboard"></i> ツリーインデックス

ツリーインデックスはベクトルをツリー構造に分割します。

<div class="academy-img-sm">
  <img
    src="https://upload.wikimedia.org/wikipedia/commons/4/46/Complete_binary.svg"
    alt="Complete binary tree (Wikipedia)"
  />
</div>

ANNOY（Approximate Nearest Neighbors Oh Yeah）は代表的なツリーインデックスで、ベクトルを二分木に分割します。

メモリ効率が高く、低次元ベクトルに適しています。

ツリーの特性上、時間とともにインデックスを更新するコストが高くなる場合があります。これはツリーを再構築する必要があるか、インクリメンタルに更新できるかによります。

ANNOY 自体はインクリメンタル更新をサポートしていません。

### <i class="fa-solid fa-chalkboard"></i> クラスタインデックス

クラスタインデックスはベクトルを類似度に基づいてグループ化します。その結果、検索空間は最も近傍が存在する可能性が高いクラスタのみに絞られます。

検索精度（リコール・適合率）はグラフインデックスより低い傾向がありますが、メモリ効率に優れています。

### <i class="fa-solid fa-chalkboard"></i> フラットインデックス

フラットインデックスは最も単純なインデックスで、すべてのベクトルを 1 つのリストに保存し、全件を走査して最近傍を探します。

メモリ効率は非常に高いものの、検索時間はベクトル数に比例して線形に増加するため、スケールは困難です。

### <i class="fa-solid fa-chalkboard"></i> Weaviate で利用可能なベクトルインデックス

Weaviate は `hnsw`、`flat`、`dynamic` の複数のベクトルインデックスタイプをサポートしています。

詳細は次のセクションで説明します。

## 質問とフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>
---
title: データのインポート
description: "Named Vectors コレクションへのデータのインポート"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import FilteredTextBlock from '@site/src/components/Documentation/FilteredTextBlock';
import PyCode from '!!raw-loader!../_snippets/102_collection.py';

## <i class="fa-solid fa-code"></i> コード

この例では、映画データをコレクションにインポートします。

驚くべきことに、[マルチモーダルコース](../../starter_multimodal_data/102_mm_collections/20_create_collection.mdx)で単一ベクトル構成に使用したのとまったく同じコードをここでも利用できます。これは、名前付きベクトルの設定がコレクション定義内で行われており、残りを Weaviate が処理してくれるためです。

<FilteredTextBlock
  text={PyCode}
  startMarker="# BatchImportData"
  endMarker="# END BatchImportData"
  language="py"
/>

コードの流れ:
- 元のテキストと画像データを読み込む
- コレクションを取得する
- バッチャー (`batch`) オブジェクトを使ってコンテキストマネージャーに入る
- データをループ処理し、  
    - テキストに対応する画像を見つける  
    - 画像を base64 に変換する  
    - オブジェクトをバッチャーに追加する
- インポートエラーを出力する

コードの詳細な解説はここでは繰り返しません。同じ内容はマルチモーダルコースで説明していますので、復習したい場合は[こちら](../../starter_multimodal_data/102_mm_collections/20_create_collection.mdx)をご覧ください。

## <i class="fa-solid fa-square-chevron-right"></i> ベクトルの生成元

バッチャーがキューを Weaviate に送信すると、オブジェクトがコレクション（今回は映画コレクション）へ追加されます。

ここで思い出してほしいのは、各オブジェクトには `title`、`overview`、`poster_title` の 3 つの名前付きベクトルがあるという点です。これらのベクトルは、コレクション定義で設定したベクトライザーによって生成されます。

- `title` ベクトルは `text2vec-openai` ベクトライザーで生成されます
- `overview` ベクトルは `text2vec-openai` ベクトライザーで生成されます
- `poster_title` ベクトルは `multi2vec-clip` ベクトライザーで生成されます

次のセクションでは、これらの名前付きベクトルが検索時にどのような柔軟性を提供するかを探っていきます。

## 質問とフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>
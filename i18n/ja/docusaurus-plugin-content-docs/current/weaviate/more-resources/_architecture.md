---
title: アーキテクチャ
sidebar_position: 4
image: og/docs/more-resources.jpg
# tags: ['Architecture']
---


...

## 追加リソース - 箇条書き、公開準備前（！）

以下は箇条書きのメモです。正式な文章へと書き換える必要があります。  
詳細に記載していますが、公開に不適切な内容があれば、一般的な意味が変わらない範囲で削除してください。  
また、すべての箇条書きはかなり率直な表現になっています。同じ内容でもマーケティング向けに言い換えたほうが良い場合は、自由に調整してください。

## 0.22.x（「サードパーティーセットアップ」）

### 10,000 feet ビュー
* 「Core」 Weaviate アプリケーション（Weaviate Stack と混同しないでください）はステートレスで、データをサードパーティーのデータベースに保存します  
* 使用しているデータベースは `etcd` と `Elasticsearch` の 2 種類です  
* `etcd` は主に歴史的理由で採用されており、設定、スキーマ、contextionary の拡張を保存しています  
* `Elasticsearch` はすべてのデータオブジェクトを保存し、検索機能を提供します  
* 「Core」 Weaviate アプリケーションは、テキストからベクトルへの変換、データオブジェクトのスキーマ拡張、クロスリファレンスの構築と解決、バリデーション、および各種 API を担当します  

### ベクトル検索
* ベクトル検索が実行されると、Core は Contextionary を用いてクエリテキストをベクトルに変換し、それを Elasticsearch に渡します  
* Elasticsearch は OSS プラグイン `lior-k/fast-elasticsearch-vector-scoring` を使用してコサイン類似度を比較します  
* これは素朴で網羅的な手法であり、クエリベクトルをインデックス内のすべてのベクトルと比較するため、計算量は O(n) です  

### 構造化検索
* 構造化検索では、標準の ES/Lucene 転置インデックスが使用されます  

### その他
* 1 つの Weaviate スキーマクラスは 1 つの Elasticsearch インデックスに対応します  
* デフォルトで、1 インデックスにつき 3 つの Elasticsearch シャードが作成されます  
* Weaviate データベースはステートレスのため、水平スケールが容易です  
* Elasticsearch は水平スケールが可能です  
* `etcd` も水平スケールが可能ですが、スタック内でボトルネックになる可能性は低いです  
* contextionary コンテナ（「Semantic Search Extension」使用時のみ存在）は、インポート時とクエリ時の両方でテキストをベクトル化します  
* インポート時には、contextionary コンテナと Elasticsearch コンテナの両方で負荷がピークになることが一般的です。通常、最初にスケールが必要になるコンポーネントです。経験則として、クラスターを監視し、リソースを最も消費している部分をスケールしてください。データセットごとに必要なリソースは異なります。  

## 1.0.0（「スタンドアロン」）

### 10,000 feet ビュー
* 「Core」 Weaviate アプリケーションがすべての永続化を担当し、サードパーティーのデータベースは不要です  
* Weaviate の永続化レイヤーはベクトルネイティブに設計されています。同時に、0.22.x で人気だった構造化検索とベクトル検索の組み合わせも提供します  
* 各クラスは 1 インデックスにマッピングされます。インデックスは 1..n 個のシャードから構成される自己完結型ユニットです  
* 各シャードは 3 つの部分からなる自己完結型ユニットです：(1) ユーザーが入力したデータオブジェクトを保持するキー・バリュー ストア、(2) 構造化検索を可能にする Lucene 風の転置インデックス、(3) ベクトル検索を可能にするベクトルインデックス  
* キー・バリュー ストアと転置インデックスはディスク操作に `boltdb` を使用します  
* ベクトルインデックスは永続化に最適化した独自実装の `hnsw` です。将来的には他のベクトルインデックスも利用可能になりますが、多くのケースで HNSW が適切に機能します  

### ベクトル検索
* 「Semantic Search Extension」を使用している場合、Contextionary がテキストをクエリベクトルに変換し、使用していない場合はユーザーがベクトルを直接提供します  
* 対象クラスインデックスの内部 HNSW インデックスを使用して kNN 検索を行います  
* HNSW はドキュメント ID を返し、それを転置インデックスとオブジェクトデータのキー・バリュー ストアで解決して完全なデータオブジェクトへ変換します  
* このプロセスの計算量は概ね O(log n) で、大規模インデックスでは桁違いに高速です  

### 構造化検索
* ベクトル検索を組み合わせない純粋な構造化検索では、転置インデックスを用いてドキュメント ID を取得し、その ID を解決してデータオブジェクトを取得し、ユーザーへ返します  
* ベクトル検索と構造化検索を組み合わせる場合、転置インデックスでマッチするドキュメント ID の許可リスト（allow list）を作成し、それをベクトルインデックスへ渡します。（以下は HNSW 特有の挙動です）ベクトルインデックスは通常どおりリンクを辿りますが、最下層では許可リストに含まれるドキュメント ID のみを結果に含めます  
* 将来的な最適化として、ベクトルインデックスをスキップし、許可リストに対して素朴検索を行う予定です。素朴検索が有利になるケースは 2 つあります：(1) 許可リストが短い場合、比較回数が少なくなるため素朴検索のほうが速い。(2) 逆に HNSW は許可リストが短い場合に遅くなる可能性があります。許可されたアイテムがクエリベクトルから非常に遠い位置にある場合（つまり、より近いマッチが許可リストに含まれない場合）、検索が網羅的になりやすいためです。ただしこの「網羅的」はインデックス全体に対するもので、かなり遅くなることがあります。例として、インデックスに 10 億件あり、許可リストに 2 件しか含まれない場合を考えてください。クエリベクトルに近い 5 億件が許可リストに含まれず、素朴検索なら比較は 2 回で済みますが、HNSW では 5 億回のベクトル比較が発生する場合があります。  

### マルチノード構成 / 分散構成 / 水平スケール
* この機能は `1.0.0` にはまだ含まれず、将来のリリースで提供予定です。ただし永続化レイヤー全体は水平スケールを念頭に設計されています  
* シャードの目的は、インデックスの一部をクラスター内の複数ノードに分散することです  
* レプリケーションはマスターなしで行われます。つまりプライマリやセカンダリの区別がなく、どのレプリカも書き込みを受け付けます。そのため、シャード数が 1 でも真の水平スケールが可能です  
* 例:  
  * 5 ノードクラスターで、1 インデックスが 1 シャード、レプリケーション 5 の場合、各ノードがインデックス全体のコピーを保持します。ディスク/メモリ要件はインデックスの 5 倍です。最大 4 ノードがダウンしてもすべてのデータを提供でき、高い可用性を持ちます。また、インデックスの特定領域に偏ったクエリでも全ノードが完全に回答できるため、クエリ性能は最も高くなります。  
  * 5 ノードクラスターで、1 インデックスが 5 シャード、レプリケーション 3 の場合、各ノードは 3 つ（異なる）シャードを保持します。ディスク/メモリ要件はインデックスの 3 倍です（5 シャード × 1/5 ずつ × 3 レプリカ → 3）。最大 2 ノードがダウンしてもすべてのデータを提供できますが、3 ノード以上ダウンすると、同一シャードを保持する 3 ノードすべてが停止する可能性があり、その場合該当シャード（インデックス全体の 1/5）が提供できなくなります。  
  * 5 ノードクラスターで、1 インデックスが 1 シャード、レプリケーション 3 の場合: クラスターは十分に活用されていません。単一シャードが 3 ノードに複製され、残り 2 ノードはデータを保持せずアイドル状態になります。この場合はシャード数を増やすべきです。  
* Weaviate は CAP 定理において AP データベースです。  



### メモリ使用量
* HNSW インデックスはメモリに収まる必要があります。ただし、これはすべての ベクトル がメモリに入る必要があるという意味ではなく、インデックス構造（多数のリンクを持つグラフ）だけが収まればよいことに注意してください。十分なメモリを確保できない場合、 Weaviate は起動できません。  
* 類似度比較でよく使用される ベクトル はキャッシュされます。そのため、すべての ベクトル をメモリに収める必要はありません。キャッシュがいっぱいになると項目は削除されます。キャッシュが頻繁に削除されるとディスク読み取りが増加します。最大のパフォーマンスを得るには、キャッシュがすべての ベクトル を収容できるサイズであることが理想です。ただし、メモリ要件が特に重要となる大規模クラスタでは、検索クエリがインデックス全体に均一に分散されることは稀です。そのため、多くの実際のケースでは、すべての ベクトル より小さいキャッシュでも高いパフォーマンスを達成できます。  
* 転置インデックスとオブジェクトストレージ用のキー・バリュー・ストアはメモリマップされています。そのため、利用可能メモリのおおよそ 50%（データセットとクエリプロファイルにより異なります）を Linux ページキャッシュとして残しておくべきです。  

## 0.22.x の Standalone モード
<!-- **NOTE: KEEP THIS HEADER FOR REFS FROM THE SOFTWARE ERROR MESSAGES (/docs/weaviate/more-resources/architecture.html#standalone-mode-in-022x)** -->

* **重要**: Standalone モードは、1.0.0 で標準となる Standalone 機能のプレビューですが、Standalone モードは **1.0.0 のプレビューではありません**。言い換えると、1.0.0 への移行時には、0.22.x の Standalone モードには反映されていない破壊的変更が含まれる可能性があります。  
* 0.22.16 時点では、Standalone モードはまだ機能が完全ではありません。  
* 0.22.x の Standalone モードは、 Weaviate が永続化に外部 DB に依存しなくなった場合の姿をプレビューすることを目的としています。  
* 0.22.16 現在、Standalone モードにはスタックに `etcd` が依然として必要です。これは技術的な理由ではなく、現在 `etcd` に保存されているデータを置き換える仕組みが Weaviate Standalone にまだ組み込まれていないためです。`etcd` は 1.0.0 までに完全に削除される予定です。  
* 0.22.16 現在、各インデックスは 1 シャードのみです。カスタムのシャード数のサポートは `1.0.0` までに追加されます。  

## 質問とフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>


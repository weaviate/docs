---
title: インデックスタイプとパフォーマンス
sidebar_position: 7
image: og/docs/more-resources.jpg
# tags: ['performance']
---

Weaviate はパフォーマンス目標を達成するために、さまざまなインデックスタイプを使用します。  
このページでは、 [ HNSW ](https://arxiv.org/abs/1603.09320) と [ 転置インデックス ](https://en.wikipedia.org/wiki/Inverted_index) に焦点を当てます。

以下のインデックスが利用可能です。

ベクトルインデックス:

- [HNSW](/weaviate/config-refs/indexing/vector-index.mdx#hnsw-index)
- [Flat](/weaviate/config-refs/indexing/vector-index.mdx#flat-index)

従来型インデックス:

- [Inverted index](#inverted-index)

## 転置インデックス
転置インデックスは、ベクトルやセマンティクスを必要とせずに結果を見つける [ GraphQL `where` フィルター](../api/graphql/filters.md) を支える仕組みです。転置インデックスでは、単語や数値などのコンテンツやデータオブジェクトのプロパティが、データベース内の位置にマッピングされます。これは、ドキュメントからその内容へマッピングする従来のフォワードインデックスとは逆の構造です。

転置インデックスはドキュメント検索システムや検索エンジンでよく使用され、ブルートフォースを用いずに高速な全文検索やキー検索を可能にします。この高速なデータ取得の代償は、新しいデータオブジェクト追加時の処理時間がわずかに増えることだけです。これは、データオブジェクトを単に保存するのではなく、転置方式でインデックス化・保存する必要があるためです。データベース（Weaviate）には、すべての転置インデックスを保持する大きなルックアップテーブルがあります。特定のプロパティやコンテンツを持つオブジェクトを取得したい場合、データベースはそのプロパティを含む 1 行のみを検索し、関連するデータオブジェクト（行にはデータオブジェクト ID へのポインタが格納されています）を指し示します。これにより、この種のクエリでのデータオブジェクト取得は非常に高速になります。エントリーが 10 億件以上あっても、特定の単語やプロパティを含むエントリーだけを対象にする場合、読まれるのはポインタを含む 1 行だけです。

転置インデックスは現在、ソートのための重み付け（例: tf-idf）を行いません。これらの機能にはベクトルインデックスが使用されるためです。そのため転置インデックスは現状、結果リストからデータオブジェクトを含めるか除外するかの二択、いわば「許可リスト」を作るためのバイナリ操作となります。

## ベクトルインデックス
ベクトルを持つすべてのデータオブジェクトは、ベクトルインデックスにも登録されます。Weaviate は現在、 [ HNSW ](https://arxiv.org/abs/1603.09320) と Flat のベクトルインデックスをサポートしています。

詳細は [Concepts: vector index](../concepts/indexing/vector-index.md) をご覧ください。

## クエリおよび操作のコスト

このセクションでは、一般的な操作のコストについて説明します。

### データインポートのコスト
現時点では、HNSW インデックス化の影響でデータインポートはクエリ時間に比べて相対的に遅くなります。もっとも安価なデータインポート操作は、以前に存在しなかったデータオブジェクトの単純な書き込みです。まったく新しいインデックスが付与されます。データオブジェクトを更新する場合も安価で、バックエンドではまったく新しいオブジェクトが作成され、新規オブジェクトとしてインデックス化されます。古いオブジェクトは非同期でクリーンアップされるため、その分の時間が追加でかかります。

### クエリのコスト
`where` フィルターのみを持つ単純な `Get` クエリは非常に安価で、 [転置インデックス](#inverted-index) が使用されます。`explore` フィルター（ベクトル検索）のみを使用する単純な `Get` クエリも同様に安価で、高速なベクトルインデックス HNSW が利用されます。2,000 万〜 1 億件以上のデータセットでも、20NN ベクトルクエリで 50ms 未満が可能です。Weaviate は複数のキャッシュに依存していますが、すべてのベクトルをメモリに常駐させる必要はありません。そのため、全ベクトルサイズよりメモリが少ないマシンでも Weaviate を実行できます。

`explore`（ベクトル）と `where` フィルターを 1 つの検索クエリで組み合わせる（これが Weaviate の特長）は、わずかに高コストになります。まず転置インデックスが呼び出され、`where` フィルターに一致するすべてのデータアイテムを返します。そのリストが HNSW によるベクトルインデックス検索に渡されます。この複合操作のコストは、データセットサイズと転置インデックス検索で返されたデータ量に依存します。`where` フィルターの結果が少ないほど、ベクトル検索がスキップする項目が増え時間が延びます。ただし、差は非常に小さく、体感できない程度です。

### 参照解決のコスト
Weaviate はグラフライクなデータモデルを持つデータベースですが、純粋なグラフデータベースではありません。グラフデータベースはリンクや参照を辿る操作が安価であり、複数アイテムを検索するよりリンククエリが安価です。一方、Weaviate は [ベクトルデータベース](https://weaviate.io/blog/what-is-a-vector-database) です。そのため、Weaviate で最も安価な操作の 1 つはデータのリスト取得であり、従来のグラフデータベースでは高コストになる操作です。Weaviate にはベクトル検索を中心としつつグラフ機能も備わっています。そのため、転置インデックスやベクトルインデックスによる検索が主目的でありながら、データオブジェクト間のグラフ参照も提供します。結果として、データオブジェクトの検索に比べ、グラフ参照の検索・追跡・取得は最適化の度合いが低く、より多くのクエリ時間を要します。

特に重要なのは、データオブジェクト間の接続数が多いほど、また単一クエリでより深く辿るほどクエリコストが増大する点です。こうしたクエリを扱う最良の方法は、*広く*かつ*深く*検索しないことです。多くのネスト参照を解決する必要がある場合は、返却件数（limit）を低く設定してください。また、すべての参照を一度に解決しないことも有効です。クエリに応じて複数クエリに分割できます。実際には、まずトップ 100 のデータオブジェクトを取得し、関心のある上位 5 件のみで深い参照を取得するといった方法が考えられます。

### 参照によるフィルターのコスト
ネストした参照フィルターを使用する場合、Weaviate は最も深い参照を解決してから、内側の層へと順に上がって他の参照を解決します。つまり、最深層の参照のビーコンを最初に取得します。これにより他の層では転置インデックスのルックアップを使用でき、マッチングは比較的安価になります。しかし、フィルター内にネスト参照を持つクエリは、それでも複数検索（各ネスト層ごと）が行われ、その結果を一つに結合する必要があるため比較的高コストです。内部層で大量の結果が返されるほど、一つ上の層が検索すべき対象が増えるため、コストは理論的には指数的に上がり得ます。

ネストの深いフィルターは可能な限り避けてください。また、クエリをできる限り制限的にするのも有効です。たとえば 10 階層のクエリでも、各階層が 1 件のみを返すのであればそれほど高コストではありません。この場合、1 件検索を 10 回実行するだけなので、クエリ内の検索回数は多いものの、各検索自体は非常に安価です。

## 質問とフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>


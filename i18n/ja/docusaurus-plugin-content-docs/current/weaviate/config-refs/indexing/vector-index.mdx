---
title: ベクトルインデックス
description: Weaviate におけるベクトルインデックスの種類とパラメーターのリファレンス。
---

**[ベクトルインデックス](../../concepts/indexing/vector-index.md)** は、ベクトルファーストのデータ保存と検索を効率的に行うための仕組みです。  
サポートされているベクトルインデックスは次の 3 種類です:

- **[HNSW インデックス](#hnsw-index)**
- **[Flat インデックス](#flat-index)**
- **[Dynamic インデックス](#dynamic-index)**

## HNSW インデックス

HNSW インデックスはスケーラブルでクエリ時には非常に高速ですが、インデックス構築中にデータを追加する際にはコストが高くなります。

### HNSW インデックスのパラメーター

一部の HNSW パラメーターは変更可能ですが、コレクション作成後に変更できないものもあります。

| パラメーター                | 型      | 説明                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | 既定値     | 変更可 |
| :-------------------------- | :------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--------- | :----- |
| `cleanupIntervalSeconds`    | integer | クリーンアップの実行間隔。通常は調整する必要はありません。値を大きくするとクリーンアップの実行回数が減りますが、一度に処理する量が増えます。値を小さくするとクリーンアップは頻繁になりますが、各実行あたりの効率が下がる場合があります。                                                                                                                                                                                                                                        | 300        | Yes    |
| `distance`                  | string  | 距離メトリック。任意の 2 つのベクトル間の距離を測定する指標です。利用可能なメトリックは [対応距離メトリック](/weaviate/config-refs/distances.md) をご参照ください。                                                                                                                                                                                                                                                                                                          | `cosine`   | No     |
| `ef`                        | integer | 検索速度とリコールのバランスを調整します。`ef` は検索時に HNSW が使用する動的リストのサイズです。`ef` が大きいほど検索の精度は向上しますが、速度は低下します。`ef` が 512 を超えるとリコールの改善は逓減します。<br/><br/>動的 `ef`。`ef` を -1 に設定すると、Weaviate が `ef` の値を自動で調整し、動的 `ef` リストを作成します。詳細は [dynamic ef](../../concepts/indexing/vector-index.md#dynamic-ef) をご覧ください。 | -1         | Yes    |
| `efConstruction`            | integer | インデックス検索速度と構築速度のバランスを調整します。`efConstruction` を高くすると `ef` を低く設定できますが、インポートは遅くなります。<br/><br/>`efConstruction` は 0 より大きい必要があります。                                                                                                                                                                                                                                                                                  | 128        | No     |
| `maxConnections`            | integer | 要素ごとの最大接続数。`maxConnections` は 0 以外のレイヤーでの接続上限です。0 レイヤーでは (2 \* `maxConnections`) の接続が可能です。<br/><br/>`maxConnections` は 0 より大きい必要があります。                                                                                                                                                                                                                                                                                        | 32         | No     |
| `dynamicEfMin`              | integer | [動的 `ef`](../../concepts/indexing/vector-index.md#dynamic-ef) の下限値。検索リストが短くなりすぎるのを防ぎます。<br/><br/>この設定は `ef` が -1 の場合のみ使用されます。                                                                                                                                                                                                                                                                                                         | 100        | Yes    |
| `dynamicEfMax`              | integer | [動的 `ef`](../../concepts/indexing/vector-index.md#dynamic-ef) の上限値。検索リストが長くなりすぎるのを防ぎます。<br/><br/>`dynamicEfMax` が制限値を超える場合、`dynamicEfMax` は無効となり、その場合の制限値は `ef` です。<br/><br/>この設定は `ef` が -1 の場合のみ使用されます。                                                                                                                                                                               | 500        | Yes    |
| `dynamicEfFactor`           | integer | [動的 `ef`](../../concepts/indexing/vector-index.md#dynamic-ef) の乗数。検索リストの潜在的な長さを設定します。<br/><br/>この設定は `ef` が -1 の場合のみ使用されます。                                                                                                                                                                                                                                                                                                            | 8          | Yes    |
| `filterStrategy`            | string  | `v1.27.0` で追加。検索結果のフィルタリングに使用するフィルターストラテジー。`sweeping` または `acorn` を指定できます。<br/><br/> - `sweeping`: 既定のストラテジー<br/> - `acorn`: Weaviate の ACORN 実装を使用します。[詳細](../../concepts/filtering.md#filter-strategy)                                                                                                                                                                            | `sweeping` | Yes    |
| `flatSearchCutoff`          | integer | オプション。[フラット検索カットオフ](/weaviate/concepts/filtering.md#flat-search-cutoff) の閾値。ベクトルインデックス検索を強制するには `"flatSearchCutoff": 0` を設定してください。                                                                                                                                                                                                                                                                                         | 40000      | Yes    |
| `skip`                      | boolean | `true` にするとコレクションをインデックスしません。<br/><br/>Weaviate はベクトル生成とベクトル保存を分離しています。インデックスをスキップしてもベクトライザーが設定されている（または手動でベクトルを指定している）場合、インポートのたびに警告が記録されます。<br/><br/>インデックスとベクトル生成を共にスキップするには、`"skip": true` を設定する際に `"vectorizer": "none"` を指定してください。<br/><br/>詳細は [インデックスをスキップするタイミング](../../concepts/indexing/vector-index.md#when-to-skip-indexing) を参照してください。 | `false`    | No     |
| `vectorCacheMaxObjects`     | integer | メモリキャッシュ内のオブジェクトの最大数。デフォルトでは、新しいコレクション作成時に 1 兆 (`1e12`) オブジェクトに設定されています。サイジングの推奨事項は [ベクトルキャッシュの考慮事項](../../concepts/indexing/vector-index.md#vector-cache-considerations) をご確認ください。                                                                                                                                                                                                                                             | `1e12`     | Yes    |
| `pq`                        | object  | [直積量子化 (PQ)](/weaviate/concepts/indexing/vector-index.md) 圧縮を有効化して設定します。<br/><br/>PQ はある程度のデータがすでにロードされていることを前提とします。PQ を有効にする前に、1 シャード当たり 10,000 ～ 100,000 ベクトルがロードされていることを推奨します。<br/><br/>PQ の詳細設定は [PQ 設定パラメーター](#pq-parameters) をご覧ください。                                                                                                                  | --         | Yes    |

### HNSW 用のデータベースパラメーター

HNSW のインデックス動作を構成するためのデータベースレベルのパラメーターもあります。

- `PERSISTENCE_HNSW_MAX_LOG_SIZE` は HNSW の書き込み先行ログの最大サイズを設定します。既定値は `500MiB` です。

この値を大きくするとコンパクションプロセスの効率が向上しますが、データベースのメモリ使用量も増えます。逆に小さくするとメモリ使用量は減りますが、コンパクションが遅くなる可能性があります。

理想的には、`PERSISTENCE_HNSW_MAX_LOG_SIZE` は HNSW グラフのサイズに近い値に設定してください。

### Tombstone クリーンアップパラメーター

:::info Environment variable availability

- `TOMBSTONE_DELETION_CONCURRENCY` は `v1.24.0` 以降で利用可能です。  
- `TOMBSTONE_DELETION_MIN_PER_CYCLE` と `TOMBSTONE_DELETION_MAX_PER_CYCLE` は `v1.24.15` / `v1.25.2` 以降で利用可能です。

:::

Tombstone は削除されたオブジェクトを示すレコードです。HNSW インデックスでは `cleanupIntervalSeconds` で定期的にクリーンアップがトリガーされます。

インデックスが大きくなると、クリーンアップ処理にかかる時間とリソースが増加し、大規模なインデックスではパフォーマンス問題を引き起こす場合があります。

クリーンアップサイクルあたりに削除される Tombstone の数を制御し、パフォーマンス問題を防ぐために、[`TOMBSTONE_DELETION_MAX_PER_CYCLE` と `TOMBSTONE_DELETION_MIN_PER_CYCLE` の環境変数](/deploy/configuration/env-vars/index.md#general) を設定してください。

- `TOMBSTONE_DELETION_MIN_PER_CYCLE` を設定して、不必要なクリーンアップサイクルの発生を防ぎます。  
- `TOMBSTONE_DELETION_MAX_PER_CYCLE` を設定して、クリーンアップが長時間実行されたり過剰にリソースを消費したりするのを防ぎます。

例として、1 シャードあたり 3 億オブジェクトのクラスターでは、`TOMBSTONE_DELETION_MIN_PER_CYCLE` を 1,000,000、`TOMBSTONE_DELETION_MAX_PER_CYCLE` を 10,000,000 に設定すると良い出発点となります。

また、`TOMBSTONE_DELETION_CONCURRENCY` 環境変数を設定して Tombstone クリーンアップに使用するスレッド数を制限できます。これにより、クリーンアップが不要に多くのリソースを消費したり、逆に時間がかかりすぎたりするのを防げます。

`TOMBSTONE_DELETION_CONCURRENCY` の既定値は、Weaviate が利用できる CPU コア数の半分です。

コア数が多いクラスターでは、クリーンアップがリソースを消費しすぎないよう `TOMBSTONE_DELETION_CONCURRENCY` を低めに設定することを検討してください。逆にコア数が少なく削除が多い場合は、クリーンアップを高速化するために値を高くするとよいでしょう。

### HNSW 設定のヒント

ご自身のユースケースに適した値を決めるため、以下の質問を検討し、表と照らし合わせてください。

1. 1 秒あたりどれくらいのクエリを想定していますか?  
1. インポートや更新は多いですか?  
1. リコールはどの程度必要ですか?

| クエリ数 | インポート / 更新が多いか | リコール | 構成の提案                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| -------- | ------------------------ | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 少ない    | いいえ                  | 低い     | 理想的なシナリオです。`ef` と `efConstruction` をいずれも低く保ちます。大きなマシンは不要で、結果にも満足できるでしょう。                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 少ない    | いいえ                  | 高い     | リコールを高くする必要があります。リクエストやインポートが少ないため、`ef` と `efConstruction` の両方を増やせます。リコールが満足いくまで段階的に増やしてください。この場合、ほぼ 100% に近づけることも可能です。                                                                                                                                                                                                                                                                                                                                                                      |
| 少ない    | はい                    | 低い     | インポート / 更新の量が多い点が課題です。`efConstruction` は低く保ちます。高いリコールは不要でクエリ数も少ないため、`ef` を調整して希望のリコールを得てください。                                                                                                                                                                                                                                                                                                                                                                                                               |
| 少ない    | はい                    | 高い     | 高いリコールが必要で、インポート / 更新も多いという難しいトレードオフです。`efConstruction` を低く保つ必要がありますが、クエリ数が少ないため `ef` を大きく設定できます。                                                                                                                                                                                                                                                                                                                                                                                                       |
| 多い      | いいえ                  | 低い     | クエリ数が多いため `ef` は低くする必要があります。幸いリコールは高くなくてよいので、`efConstruction` を大きくできます。                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 多い      | いいえ                  | 高い     | クエリ数が多いため `ef` は低くします。リコールを高くする必要がありますが、インポートや更新は多くないため `efConstruction` を増やしてリコールを調整します。                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 多い      | はい                    | 低い     | クエリ数が多いので `ef` は低く、インポート / 更新も多いため `efConstruction` も低くします。リコールを 100% に近づける必要がないので、`efConstruction` を比較的低く設定してインポート / 更新スループットを確保し、`ef` で QPS を調整します。                                                                                                                                                                                                                                                                                                                              |
| 多い      | はい                    | 高い     | すべてを最高にしたい場合です。インポート / 更新の時間制限に達するまで `efConstruction` を増やし、その後クエリ数とリコールのバランスが取れるまで `ef` を増やします。<br/><br/>多くの人は 3 つすべての指標を最大化したいと考えがちですが、実際にはそうでないケースも多いです。判断に迷ったら [フォーラム](https://forum.weaviate.io) でご相談ください。 |

:::tip
多くのユースケースでの出発点として、以下の値が適しています。

| パラメーター        | 値   |
| :------------------ | :--- |
| `ef`               | `64` |
| `efConstruction`   | `128`|
| `maxConnections`   | `32` |

:::

## Flat インデックス

:::info Added in `v1.23`
:::

Flat インデックスは、マルチテナンシーなど、インデックスあたりのオブジェクト数が少ないユースケースで推奨されます。

| パラメーター                | 型      | 既定値  | 変更可 | 詳細                                                                                                                                                                                                                                                                                                   |
| :-------------------------- | :------ | :------ | :----- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `vectorCacheMaxObjects`     | integer | `1e12`  | Yes    | メモリキャッシュ内のオブジェクトの最大数。デフォルトでは、新しいコレクション作成時に 1 兆 (`1e12`) オブジェクトに設定されています。サイジングの推奨事項は [ベクトルキャッシュの考慮事項](../../concepts/indexing/vector-index.md#vector-cache-considerations) をご参照ください。 |
| `bq`                        | object  | --      | No     | [バイナリ量子化 (BQ)](../../concepts/vector-quantization.md#binary-quantization) 圧縮を有効化して設定します。<br/><br/>BQ の詳細設定は [BQ 設定パラメーター](#bq-configuration-parameters) をご覧ください。                                                                                     |

### BQ 設定パラメーター

`bq` は次のパラメーターで構成します。

| パラメーター      | 型      | 既定値 | 詳細                                                       |
| :--------------- | :------ | :----- | :--------------------------------------------------------- |
| `enabled`        | boolean | `false`| BQ を有効化します。`true` にすると Weaviate は BQ 圧縮を使用します。|
| `rescoreLimit`   | integer | -1     | リスコアを行う前に取得する最小候補数。                     |
| `cache`          | boolean | `false`| ベクトルキャッシュを使用するかどうか。                     |



## 動的インデックス

:::caution Experimental feature
`v1.25` から利用可能です。動的インデックスは実験的機能です。ご使用の際はご注意ください。
:::

import DynamicAsyncRequirements from "/_includes/dynamic-index-async-req.mdx";

<DynamicAsyncRequirements />

`dynamic` インデックスを使用すると、初期状態ではフラットインデックスが作成され、オブジェクト数がしきい値（デフォルトでは 10,000 件）を超えると自動的に HNSW インデックスへ切り替わります。

これはフラットインデックスを HNSW に一方向で変換するのみで、削除によってオブジェクト数がしきい値を下回ってもフラットインデックスへ戻ることはできません。

`dynamic` インデックスの目的は、より大きなメモリフットプリントと引き換えにクエリ時間のレイテンシを短縮することです。

### 動的インデックスのパラメーター

| Parameter   | Type    | Default      | Details                                                                               |
| :---------- | :------ | :----------- | :------------------------------------------------------------------------------------ |
| `distance`  | string  | `cosine`     | 距離メトリクス。２つの任意の ベクトル 間の距離を測定するメトリクスです。 |
| `hnsw`      | object  | default HNSW | 使用する [ HNSW インデックス設定](#hnsw-index-parameters)。                        |
| `flat`      | object  | default Flat | 使用する [フラットインデックス設定](#flat-index)。                                 |
| `threshold` | integer | 10000        | `flat` から `hnsw` への変換が行われるオブジェクト数のしきい値                       |

## インデックス設定パラメーター

:::caution Experimental feature
`v1.25` から利用可能です。動的インデックスは実験的機能です。ご使用の際はご注意ください。
:::

以下のパラメーターでインデックスタイプとそのプロパティを設定できます。これらは [コレクション設定](../../manage-collections/vector-config.mdx#set-vector-index-type) で指定します。

| Parameter           | Type   | Default | Details                                                              |
| :------------------ | :----- | :------ | :------------------------------------------------------------------- |
| `vectorIndexType`   | string | `hnsw`  | 任意。インデックスタイプ。`hnsw`、`flat`、`dynamic` から選択できます。       |
| `vectorIndexConfig` | object | -       | 任意。 ベクトル インデックスタイプ固有のパラメーターを設定します。 |

<details>
  <summary>インデックスタイプの選び方</summary>

一般的には、ほとんどのユースケースで `hnsw` インデックスタイプが推奨されます。`flat` インデックスタイプは、マルチテナンシーのようにインデックスあたりのデータ（オブジェクト）数が少ないケースで推奨されます。最初に `flat` インデックスを構成し、オブジェクト数が指定のしきい値を超えたら自動で `hnsw` に変換する `dynamic` インデックスを選択することもできます。

各インデックスタイプの詳細と選択方法については [こちらのセクション](../../concepts/indexing/vector-index.md#which-vector-index-is-right-for-me) を参照してください。

</details>

インポート速度をさらに高めたい場合は、[非同期インデックス](#asynchronous-indexing) を使用してオブジェクト作成とインデックス作成を分離できます。

### RQ パラメーター

`vectorIndexConfig` 内で、RQ 圧縮に利用できるパラメーターは次のとおりです。

import RQParameters from "/_includes/configuration/rq-compression-parameters.mdx";

<RQParameters />

### SQ パラメーーター

`vectorIndexConfig` 内で、SQ 圧縮に利用できるパラメーターは次のとおりです。

import SQParameters from "/_includes/configuration/sq-compression-parameters.mdx";

<SQParameters />

### PQ パラメーター

`vectorIndexConfig` 内で、PQ 圧縮に利用できるパラメーターは次のとおりです。

import PQParameters from "/_includes/configuration/pq-compression/parameters.mdx";

<PQParameters />

### BQ パラメーター

`vectorIndexConfig` 内で、BQ 圧縮に利用できるパラメーターは次のとおりです。

import BQParameters from "/_includes/configuration/bq-compression-parameters.mdx";

<BQParameters />

## セマンティックインデックスの設定

Weaviate は [モデルプロバイダー統合](/weaviate/model-providers/) を使用してオブジェクトのベクトル埋め込みを生成できます。

たとえば、テキスト埋め込み統合（Cohere 用の `text2vec-cohere` や Ollama 用の `text2vec-ollama` など）は、テキストオブジェクトから ベクトル を生成できます。Weaviate はコレクション設定と所定のルールに従ってオブジェクトをベクトライズします。

コレクション定義で別途指定しない限り、デフォルトの動作は以下のとおりです。

- `text` または `text[]` データタイプを使用するプロパティのみをベクトライズします（[スキップ](../../manage-collections/vector-config.mdx#property-level-settings) されていない限り）
- プロパティ値を連結する前に、プロパティをアルファベット（a-z）順に並べ替えます
- `vectorizePropertyName` が `true`（デフォルトは `false`）の場合、各プロパティ値の前にプロパティ名を付けます
- （前置された）プロパティ値をスペースで結合します
- クラス名を先頭に付けます（`vectorizeClassName` が `false` の場合を除く）
- 生成された文字列を小文字に変換します

例として、次のデータオブジェクト

```js
Article = {
  summary: "Cows lose their jobs as milk prices drop",
  text: "As his 100 diary cows lumbered over for their Monday...",
};
```

は以下のようにベクトライズされます。

```md
article cows lose their jobs as milk prices drop as his 100 diary cows lumbered over for their monday...
```

デフォルトでは、計算にはコレクション名とすべてのプロパティ値が含まれますが、プロパティ名はインデックスされません。

コレクション単位でベクトライズの挙動を設定するには `vectorizeClassName` を使用します。

プロパティ単位で設定するには `skip` と `vectorizePropertyName` を使用します。

## 非同期インデックス

:::caution Experimental
`v1.22` から利用可能です。こちらは実験的機能です。ご使用の際はご注意ください。
:::

Weaviate `1.22` 以降では、オプトインにより非同期インデックスを使用できます。

非同期インデックスを有効にするには、Weaviate の設定（Docker Compose を使用している場合は `docker-compose.yml` ファイル）で環境変数 `ASYNC_INDEXING` を `true` に設定します。この設定により、すべてのコレクションで非同期インデックスが有効になります。

<details>
  <summary>Docker Compose 設定例</summary>

```yaml
---
services:
  weaviate:
    command:
      - --host
      - 0.0.0.0
      - --port
      - "8080"
      - --scheme
      - http
    image: cr.weaviate.io/semitechnologies/weaviate:||site.weaviate_version||
    restart: on-failure:0
    ports:
      - 8080:8080
      - 50051:50051
    environment:
      QUERY_DEFAULTS_LIMIT: 25
      QUERY_MAXIMUM_RESULTS: 10000
      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: "true"
      PERSISTENCE_DATA_PATH: "/var/lib/weaviate"
      ENABLE_API_BASED_MODULES: "true"
      CLUSTER_HOSTNAME: "node1"
      AUTOSCHEMA_ENABLED: "false"
      ASYNC_INDEXING: "true"
```

</details>

インデックスのステータスを取得するには、[ノードステータス](/deploy/configuration/nodes.md) エンドポイントを確認します。

<details>
  <summary><code>Node status</code> の使用例</summary>

`nodes/shards/vectorQueueLength` フィールドは、まだインデックス作成が必要なオブジェクト数を示します。

import Nodes from "/_includes/code/nodes.mdx";

<Nodes />

次に、出力を確認して ベクトル インデックスキューの状態をチェックします。

<br />

`vectorQueueLength` フィールドには、残りのインデックス対象オブジェクト数が表示されます。下記の例では、`TestArticle` シャードの ベクトル インデックスキューに 1000 件中 425 件が残っていることを示しています。

```json
{
  "nodes": [
    {
      "batchStats": {
        "ratePerSecond": 0
      },
      "gitHash": "e6b37ce",
      "name": "weaviate-0",
      "shards": [
        {
          "class": "TestArticle",
          "name": "nq1Bg9Q5lxxP",
          "objectCount": 1000,
          // highlight-start
          "vectorIndexingStatus": "INDEXING",
          "vectorQueueLength": 425
          // highlight-end
        }
      ],
      "stats": {
        "objectCount": 1000,
        "shardCount": 1
      },
      "status": "HEALTHY",
      "version": "1.22.1"
    }
  ]
}
```

</details>



## 複数ベクトル埋め込み（名前付きベクトル）

import MultiVectorSupport from "/_includes/multi-vector-support.mdx";

<MultiVectorSupport />

## 追加リソース

- [概念: ベクトルインデックス](../../concepts/indexing/vector-index.md)
- [方法: コレクションを設定する](../../manage-collections/vector-config.mdx)

## 質問とフィードバック

import DocsFeedback from "/_includes/docs-feedback.mdx";

<DocsFeedback />


---
title: インデックス
sidebar_position: 50
image: og/docs/indexing.jpg
---

Weaviate は、高速でスケーラブルな検索とフィルタリングを実現するために 2 種類のインデックスを使用します。ベクトル検索には ベクトル インデックスを、フィルタリングやキーワード検索には 転置インデックス を使用します。

このページでは、Weaviate で利用できる [ベクトル インデックス](#vector-indexes) と [転置インデックス](#inverted-indexes) を紹介し、適切なインデックス戦略を立てられるようにします。

:::info インデックス作成とリソース使用
ベクトル インデックスはインデックスタイプに応じて *hot* または *warm* リソースを使用します。転置インデックスは *warm* リソースを使用します。リソースの種類については [リソース管理](./index.md) を参照してください。
:::

:::tip インデックス作成の推奨事項

- マルチテナント構成の場合は、[ダイナミック インデックス](#dynamic-indexes) を使用してください。
- インデックスタイプを選択する際はデータセットのサイズを考慮してください。
    - オブジェクト数が少ない場合は フラット インデックス を検討してください。
    - 大規模なデータセットには HNSW インデックス を使用してください。
    - 迷った場合は ダイナミック インデックス を使用してください。
- 多少の精度を犠牲にできる場合は、[圧縮](./compression.mdx) を検討してください。
    - HNSW インデックスには、[PQ](../../configuration/compression/pq-compression.md) / [SQ](../../configuration/compression/sq-compression.md) / [BQ](../../configuration/compression/bq-compression.md) を適用してメモリ要件を削減できます。
    - フラット インデックスには、[バイナリ 量子化 (BQ)](../../configuration/compression/bq-compression.md) を使用して検索速度を向上できます。
- 転置インデックスを設定する際は、クエリ要件を考慮してください。
    - ディスク容量が問題でなければ、[すべてのプロパティをインデックス](#property-level-configuration) して検索とフィルタリングを高速化します。
    - メタデータ フィルタリングが重要な場合は、[コレクションレベル](#collection-level-configuration) でインデックスしてください。

:::

## ベクトル インデックス

Weaviate では 3 種類のベクトル インデックス、[Hierarchical Navigable Small World ( HNSW ) インデックス](#hnsw-indexes)、[フラット インデックス](#flat-indexes)、そして [ダイナミック インデックス](#dynamic-indexes) を提供しています。

- HNSW インデックスは、大規模データセットでも高速かつスケーラブルな ベクトル 検索を実現します。
- フラット インデックスはメモリ効率に優れ、小規模データセットで最適に動作します。
- ダイナミック インデックスは、[コレクション](../../concepts/data.md#collections) や [テナント](../../concepts/data.md#multi-tenancy) が閾値サイズに達したとき、フラット インデックスから HNSW インデックスへ切り替わります。

#### HNSW インデックス

[HNSW](/weaviate/concepts/vector-index#hierarchical-navigable-small-world-hnsw-index) は高性能なインメモリ インデックスです。HNSW インデックスはスケール性能に優れており、非常に大規模なデータセットでも ベクトル 検索が高速に保たれます。

HNSW インデックスはオブジェクトの多層グラフを構築し、高速な近似近傍検索を実現します。

一方で HNSW インデックスはグラフ構造とベクトルをメモリにロードするため、[*hot* リソース](./index.md#-hot) を多く消費します。

HNSW インデックスのサイズ削減には [圧縮](./compression.mdx) の使用を検討してください。Weaviate では複数の圧縮方法を提供しています。

import CompressionAlgorithms from '/_includes/starter-guides/compression-types.mdx';

<CompressionAlgorithms/>

#### フラット インデックス

[フラット インデックス](/weaviate/concepts/vector-index#flat-index) はメモリ効率が高いディスクベースのインデックスで、全件走査による ベクトル 検索を行います。小規模データセットでは高速ですが、インデックスされたオブジェクト数が増えるにつれて検索速度は線形に遅くなります。

フラット インデックスは、オブジェクト数が少なく大きく増えないケースに最適です。

[バイナリ 量子化 ( BQ )](/weaviate/configuration/compression/bq-compression) を使用すると、フラット インデックスの検索速度を向上できます。BQ は読み込むデータ量を削減し、ベクトル間距離の計算を高速化します。

#### ダイナミック インデックス

:::info `v1.25` で追加
:::

import DynamicAsyncRequirements from '/_includes/dynamic-index-async-req.mdx';

<DynamicAsyncRequirements/>

[ダイナミック インデックス](/weaviate/concepts/vector-index#dynamic-index) は柔軟なインデックス方式です。ダイナミック インデックスはフラット インデックスとして開始し、オブジェクト数が閾値に達すると自動的に HNSW インデックスへ変換されます。

テナントごとにオブジェクト数が異なるマルチテナント構成では、ダイナミック インデックスが適しています。必要ない場合はテナントごとにフラット インデックスを使用できるため、オーバーヘッドが減ります。

デフォルトのインデックス変換閾値は 10,000 オブジェクトです。ダイナミック インデックス作成時にこの閾値を設定できます。

次の表は、コレクション内のオブジェクト数が増えるにつれてダイナミック インデックスがどのように変化するかを示しています。例では以下の設定を行っています。

- 変換閾値: 10,000 オブジェクト
- BQ を適用したフラット インデックス
- SQ を適用した HNSW インデックス
- SQ の学習閾値: 100,000 オブジェクト

| オブジェクト数 | インデックスタイプ | 圧縮 | 備考 |
| :- | :- | :- | :- |
| 0 - 9,999 | フラット インデックス | BQ | フラット インデックスと BQ が有効 |
| 10,000 | フラット → HNSW | なし | インデックスが HNSW に変換され、RAM にロードされる |
| 100,000 | HNSW | 学習中 | オブジェクト数が SQ 学習閾値に到達 |
| 100,001 | HNSW | SQ | HNSW と SQ が有効 |

:::info フラット インデックスと HNSW インデックスを設定
ダイナミック インデックスを定義するときに、フラット インデックスと HNSW インデックスの両方を設定してください。ダイナミック インデックスは最初にフラット インデックスを使用し、その後 HNSW インデックスへ切り替わります。どちらのインデックスも事前に設定しておく必要があります。
:::

### 非同期 ベクトル インデックス作成

:::info `v1.22` で追加
:::

HNSW インデックスの構築はリソース消費が大きく、Weaviate へのオブジェクト取り込み時間を遅くする可能性があります。

[非同期 ベクトル インデックス作成](/weaviate/config-refs/indexing/vector-index.mdx#asynchronous-indexing) を使用すると、HNSW インデックスの構築を待たずにオブジェクトを Weaviate に取り込めます。

これにより、データ取り込みと ベクトル インデックス作成を分離できます。

非同期 ベクトル インデックス作成を使用すると、HNSW インデックスの構築が完了するのを待たずにオブジェクトを取り込めます。ただし、この間の ベクトル 検索は未完成のインデックスに基づく可能性があり、検索結果に影響を与える点に注意してください。

## 転置インデックス

Weaviate はキーワード検索とフィルタリングに 転置インデックス を使用します。

転置インデックスには複数のタイプがあります。
- `indexSearchable`: キーワード検索用
- `indexFilterable`: 高速フィルタリング用
- `indexRangeFilters`: 数値範囲フィルタリングを高速化

インデックスの各要素はコレクションレベルおよびプロパティレベルで設定できます。

### コレクションレベルの設定

転置インデックスはコレクションレベルで設定できます。コレクションレベルの設定では BM25 パラメータや、フィルタリング用にどのメタデータをインデックスするかを決定します。たとえば、タイムスタンプ、null 状態、プロパティ長をインデックスするかどうかを設定できます。

詳細は [転置インデックスパラメータの設定](../../manage-collections/collection-operations.mdx#set-inverted-index-parameters) を参照してください。
### プロパティレベル設定

プロパティレベルの設定はさらに限定されています。プロパティごとに個別のインデックスを有効化または無効化でき、キーワードのトークナイズオプションを設定できます。  

`indexSearchable` は、プロパティがキーワード検索用にインデックス化されるかどうかを決定します。  
`indexFilterable` は、マッチベースのフィルタリングを高速化するためにプロパティをインデックス化するかどうかを決定します。  
`indexRangeFilters` は、数値範囲フィルタ用にプロパティをインデックス化するかどうかを決定します。

フィルタの詳細については [フィルタリング](/weaviate/concepts/filtering) をご覧ください。

## 関連ページ

詳細については、以下のドキュメントページやブログ記事をご参照ください。

### ドキュメントページ

インデックスを設定するには、次のページの手順に従ってください。

- [ベクトル インデックスの設定](/weaviate/config-refs/indexing/vector-index.mdx)
- [転置インデックスの設定](../../manage-collections/collection-operations.mdx#set-inverted-index-parameters)

さらに詳しく知りたい場合は、以下をご覧ください。

- [ベクトル インデックス](/weaviate/concepts/vector-index)
- [転置インデックス](/weaviate/concepts/indexing)

### Weaviate アカデミー

ベクトル インデックスに関する短いコースはこちら:

- [ベクトル インデックス](/academy/py/vector_index)

## ご質問やフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>
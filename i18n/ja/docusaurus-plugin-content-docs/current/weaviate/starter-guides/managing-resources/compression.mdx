---
title: 圧縮
sidebar_position: 30
image: og/docs/tutorials.jpg
# tags: ['basics']
---

Weaviate はベクトル埋め込み（「埋め込み」または単に「 ベクトル 」とも呼ばれます）を保存します。 ベクトル 埋め込みの各要素は次元です。値は一般的に 32 bit フロートとして保存されます。1536 次元の単一 ベクトル は約 6 KB のストレージを使用します。

コレクションに数百万件のオブジェクトがある場合、 ベクトル 全体のストレージサイズは非常に大きくなります。 ベクトル は保存されるだけでなく、インデックス化も行われます。このインデックスも非常に大きくなる可能性があります。 ベクトル とインデックスをホストするためのリソースコストは高額になる場合があります。

Weaviate はコレクションの ベクトル 空間を検索するためのインデックスを作成します。デフォルトの ベクトル インデックスは [Hierarchical Navigable Small World (HNSW)](/weaviate/concepts/vector-index#hierarchical-navigable-small-world-hnsw-index) インデックスです。このデータ構造には ベクトル とインデックスグラフが含まれます。HNSW インデックスは高速な ベクトル 検索と優れたリコールを維持しますが、RAM メモリに保存されるためコストが高くなる場合があります。

デフォルトのインデックス設定を変更すると、コストを大幅に削減できるだけでなく、パフォーマンスが向上することもあります。多くの場合、圧縮や別のインデックスタイプを使用して、データの保存と検索方法を変更しながら、高いリコールを維持できます。

本ページでは圧縮アルゴリズムについて説明します。インデックスの詳細は [Vector indexing](/weaviate/concepts/vector-index) を参照してください。

## 圧縮アルゴリズム

利用可能な圧縮アルゴリズムは以下のとおりです。

import CompressionAlgorithms from '/_includes/starter-guides/compression-types.mdx';

<CompressionAlgorithms />

 ベクトル を圧縮すると、検索結果の品質は非圧縮 ベクトル の特性に大きく依存します。埋め込みモデルがこれらの ベクトル を生成するため、埋め込みモデルは圧縮 ベクトル の検索性能の鍵となります。本番環境に移行する前に、さまざまな圧縮設定と埋め込みモデルを試し、モデルのドキュメントを確認して、データセットに最適な組み合わせを見つけてください。

## 圧縮の検討事項

圧縮アルゴリズムを選択する前に、[基盤となる ベクトル インデックスタイプ](#underlying-vector-index) を考慮してください。インデックスタイプによって使用できる圧縮アルゴリズムが決まります。一部の圧縮アルゴリズムは特定のインデックスタイプでは利用できません。

オブジェクト ベクトル の作成に使用する ベクトライザー によっても、選択できる圧縮方式が制限される場合があります。たとえば、特定の埋め込みモデルは BQ 圧縮専用に調整されています。

パフォーマンスとコストも重要な検討事項です。詳細は [コスト、リコール、速度](#cost-recall-and-speed) を参照してください。

### 基盤となる ベクトル インデックス

次の表は、各インデックスタイプで利用可能な圧縮アルゴリズムを示しています。

| 圧縮タイプ | HNSW インデックス | Flat インデックス | Dynamic インデックス |
| :- | :- | :- | :- |
| PQ | Yes | No | Yes |
| SQ | Yes | No | Yes |
| RQ | Yes | No | Yes |
| BQ | Yes | Yes | Yes |

[Dynamic インデックス](/weaviate/config-refs/indexing/vector-index.mdx#dynamic-index) は v1.25 で新しく追加されました。このインデックスは、コレクションがしきい値サイズに達するまでは [Flat インデックス](/weaviate/config-refs/indexing/vector-index.mdx#flat-index) です。コレクションがデフォルト値の 10,000 オブジェクトを超えると、自動的に再インデックスされ HNSW インデックスに変換されます。

### コスト、リコール、速度

パフォーマンスには速度とリコールが含まれます。実際のシステムでは、これらの要素をコストとバランスさせる必要があります。アプリケーションに慣れてきたら、プロジェクトと予算に合わせて Weaviate をチューニングできます。

#### コスト

これらの圧縮アルゴリズムには機能面でのトレードオフがありますが、コスト削減の仕組みは共通しています。 ベクトル のサイズを小さくしてインデックスを縮小します。インデックスが小さければ必要なリソースが少なくなり、コストを削減できます。

圧縮インデックスはメモリにロードした際、非圧縮 ベクトル よりも少ない RAM を使用します。ただし、ディスク上では非圧縮 ベクトル よりも多くの容量を使用します。Weaviate は非圧縮 ベクトル と圧縮 ベクトル インデックスの両方を保存するため、ディスクストレージコストは増加します。しかし RAM のコストはディスクの何桁も高いため、圧縮インデックスを使用した場合の総コストは非圧縮インデックスよりはるかに低くなります。

コスト削減の効果は、HNSW のようなインメモリインデックスで最も顕著です。RAM が多く削減されるほどコストも低下します。

- PQ 圧縮 ベクトル は通常、非圧縮 ベクトル と比べて RAM を 85% 削減します。
- SQ 圧縮 ベクトル は非圧縮 ベクトル と比べて RAM を 75% 削減します。
- RQ 圧縮 ベクトル は通常、非圧縮 ベクトル と比べて RAM を 75% 削減します。
- BQ 圧縮 ベクトル は非圧縮 ベクトル と比べて RAM を 97% 削減します。

HNSW インデックスは接続グラフと ベクトル で構成されます。量子化方式は ベクトル のサイズを減らしますが、グラフのサイズには影響しません。そのため、メモリ使用量の総削減率は ベクトル の削減率より小さくなりますが、それでも大幅に削減されます。

#### リコール

リコールは、アルゴリズムがデータセット内の真陽性をどれだけ見つけられるかを測定します。

圧縮 ベクトル は対応する非圧縮 ベクトル より情報量が少なくなります。非圧縮 ベクトル では検索クエリにマッチするはずの対象が、圧縮 ベクトル では情報が欠落しているため見逃される可能性があります。失われたマッチはリコールを低下させます。

一般的なリコール率:
- PQ: 設定により変動
- SQ: 95-97% のリコール
- RQ: 98-99% のリコール
- BQ: データとモデル特性により大きく変動

圧縮 ベクトル でリコールを改善するため、Weaviate は検索時に候補 ベクトル を過剰に取得（オーバーフェッチ）します。候補リストの各項目に対して、対応する非圧縮 ベクトル を取得します。最終的なランク付けを決定するため、Weaviate は非圧縮 ベクトル とクエリ ベクトル の距離を計算します。

import RescoringIllustration from '/docs/weaviate/starter-guides/managing-resources/img/rescore-uncompressed-vectors.png';

<img src={RescoringIllustration} width="100%" alt="Rescoring illustration"/>

リスコアリングはインメモリ検索よりも遅くなりますが、Weaviate は限られた数の非圧縮 ベクトル だけを検索すればよいので、検索自体は非常に高速です。最も重要なのは、非圧縮 ベクトル でリスコアリングすることでリコールが大幅に向上する点です。

検索アルゴリズムはオーバーフェッチとリスコアリングを使用することで、圧縮による利点を享受しながら、非圧縮 ベクトル 検索の精度を失いません。

#### クエリ速度

各圧縮アルゴリズムには速度に関する特性があります。

- PQ インデックスはリコールが 97% 以上になると、非圧縮インデックスの応答速度に近づきます。そのリコールレベルでは、PQ 圧縮インデックスの [速度プロファイル](https://weaviate.io/blog/pq-rescoring#qps-vs-recall-experiments) は非圧縮インデックスと同等です。

- BQ は高速なビット演算を使用します。BQ のビット演算は非常に効率的です。効率的な計算はブルートフォース検索に依存する Flat インデックスでは重要で、計算量が多くなります。BQ 圧縮 ベクトル の検索は、同等の非圧縮 ベクトル の検索と比べて [10〜20 倍高速](https://weaviate.io/blog/binary-quantization/#-performance-improvements-with-bq) で、リコール率も同等です。BQ は基盤データに敏感なので、Flat インデックスを使用する場合はデータセットで BQ 圧縮を評価して性能向上を確認してください。

- SQ は検索速度を大幅に向上させます。PQ より高速で、非圧縮 ベクトル 検索の 3〜4 倍程度高速です。SQ は BQ より高い次元分解能を持つためリコールを助けます。SQ 圧縮のトレードオフについては近日公開予定のブログ記事をご覧ください。

- RQ は 8-bit 量子化方式の中で最速のクエリ性能を提供します。RQ は SIMD 最適化された距離計算を使用し、通常は非圧縮 ベクトル より 2〜3 倍高速です。RQ は SQ より高速で、リコールも向上する場合があります。最大のパフォーマンスを得るために、リコールへの影響を最小限に抑えつつリスコアリングなしで実行することも可能です。

SQ と BQ にはオプションの ベクトル キャッシュがあります。構成可能なキャッシュを使用して使用頻度の高い非圧縮 ベクトル をメモリにロードし、検索時間を改善できます。

#### インポート速度

 ベクトル をインポートして圧縮するには、非圧縮 ベクトル をインポートするよりわずかに時間がかかりますが、これは一度限りのコストです。対照的に、圧縮インデックスをメモリにロードする方がデータ量が少ないため速くなります。つまり再起動が速くなります。

v1.22 以降、Weaviate にはオプションで [非同期インデックス作成](/weaviate/config-refs/indexing/vector-index.mdx#asynchronous-indexing) 機能があり、インポートプロセスを実質的に高速化します。インポートを改善するために非同期インデックス作成を有効にすることを検討してください。

### 圧縮を有効化する

- BQ、SQ、RQ はコレクション作成時に有効化する必要があります。

- PQ と SQ はどちらも圧縮を開始する前にトレーニングデータが必要です。

  - PQ のトレーニングステップでは各セグメントのセントロイドを定義します。
  - SQ のトレーニングステップではバケット境界の最小値と最大値を決定します。
  - PQ と SQ は十分なトレーニングセットをインポートし、トレーニングが完了した後に圧縮を開始します。

- RQ はトレーニングを必要とせず、 ベクトル 挿入後すぐに圧縮を開始します。このため、トレーニングフェーズを待たずに即時圧縮が必要なアプリケーションに適しています。

- 非同期インデックス作成と [AutoPQ を有効化](/weaviate/configuration/compression/pq-compression#configure-autopq) している場合、PQ 圧縮はいつでも有効にできます。AutoPQ が有効でない場合は、[アルゴリズムをトレーニング](/weaviate/configuration/compression/pq-compression#manually-configure-pq) できる十分なオブジェクトをインポートした後にのみ PQ を有効にするべきです。

- BQ はトレーニングステップを必要としません。
## 推奨事項

ほとんどのアプリケーションは圧縮の恩恵を受けます。コスト削減効果は大きく、たとえば [Weaviate Cloud](https://weaviate.io/pricing) では、圧縮コレクションは非圧縮コレクションよりも 80% 以上安価になる場合があります。

- シンプルさ・パフォーマンス・リコールのバランスを重視する HNSW インデックス利用者には、**RQ 圧縮** を検討してください。RQ は 4 倍の圧縮率で 98–99% のリコールを実現し、設定やトレーニングは不要です。OpenAI などのプロバイダーから得た標準的な埋め込みに最適です。

- フラットインデックスを使用する小規模コレクションの場合は、BQ インデックスを検討してください。BQ インデックスは非圧縮の同等構成に比べて 32 倍小さく、かつ高速です。

- 大規模なデータセットや専門的な検索ニーズがある場合は、PQ 圧縮を検討してください。PQ 圧縮は高度に設定可能ですが、SQ・RQ・BQ よりもチューニングには専門知識が必要です。

成長が見込まれる小規模コレクションには、ダイナミックインデックスの利用を検討してください。ダイナミックインデックスタイプを設定するだけでなく、インデックスがフラットの間は BQ 圧縮を使用し、コレクションが大きくなってフラットインデックスから HNSW インデックスへ移行するタイミングで RQ 圧縮を使用するよう設定します。

## 関連ページ

詳細については、以下のドキュメントページとブログ記事をご覧ください。

### ドキュメントページ

圧縮を有効にする手順は次のページをご参照ください。

- [直積量子化 (PQ)](../../configuration/compression/pq-compression.md)
- [スカラー量子化 (SQ)](../../configuration/compression/sq-compression.md)
- [回転量子化 (RQ)](../../configuration/compression/rq-compression.md)
- [バイナリ量子化 (BQ)](../../configuration/compression/bq-compression.md)

さらに詳しいドキュメントは以下をご覧ください。

- [圧縮に関する議論](/weaviate/concepts/vector-quantization)

### ブログ記事

詳細な解説は以下をご覧ください。

- [PQ とメモリ削減](https://weaviate.io/blog/pq-rescoring)
- [BQ とメモリ削減](https://weaviate.io/blog/binary-quantization)
- [PQ と HNSW の解説](https://weaviate.io/blog/ann-algorithms-hnsw-pq)

### 料金計算機

圧縮および非圧縮 ベクトル の Weaviate Cloud 料金を確認するには、以下を参照してください。

[Weaviate Cloud 料金計算機](https://weaviate.io/pricing)

## 質問とフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>
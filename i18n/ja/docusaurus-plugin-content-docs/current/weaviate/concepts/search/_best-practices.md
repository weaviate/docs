---
title: ベストプラクティス
sidebar_position: 5
image: og/docs/concepts.jpg
# tags: ['concepts', 'search', 'optimization']
---

# 検索：ベストプラクティス

このページでは、検索の品質とパフォーマンスを最適化するための推奨ベストプラクティスを示します。

## フィルター

フィルターはプロパティやメタデータに関連する特定の条件に基づいて検索結果を絞り込みます。

Weaviate では [事前フィルター](../filtering.md) を適用し、フィルターを実行してその結果をパラメーターとして検索に渡します。これにより、フィルターが非常に厳しい場合でも再現率を高く保つことができます。

各プロパティごとに [インデックスを有効化または無効化](#index-types-and-filters) したり、[オプションのメタデータをインデックス化](#optional-metadata-filtering) したりして、フィルタリング性能とディスク使用量のトレードオフを調整します。

### インデックスの種類とフィルター

Weaviate はフィルター処理を高速化するためにインデックスを利用します。

`v1.18` で、フィルター性能を向上させるために [Roaring ビットマップインデックス (`indexFilterable`)](../filtering.md#indexfilterable) が追加されました。さらに、`int`、`number`、`date` プロパティの範囲ベースの数値フィルターを高速化するため、`v1.26` で [範囲ベースインデックス (`indexRangeFilters`)](../filtering.md#indexrangefilters) が追加されました。

これらのインデックスはプロパティごとに [有効化または無効化](../../manage-collections/collection-operations.mdx#set-inverted-index-parameters) できます。

インデックスを有効化すると検索は高速化しますが、ディスクおよびメモリの使用量がわずかに増加します。

一般的な目安として、そのプロパティでフィルタリングが不要であると確信している場合を除き、`indexFilterable` と `indexRangeFilters` の両方を有効にすることを推奨します。

### オプションのメタデータフィルター

プロパティ作成時に設定しておけば、各プロパティに対して追加のメタデータフィルターをオプションで構成できます。

これらのオプションは次のとおりです。

- `indexTimestamps`: タイムスタンプベースのフィルター（作成日時または最終更新日時）用  
- `indexNullState`: null 値によるフィルター用  
- `indexPropertyLength`: テキストプロパティの長さによるフィルター用  

これらのインデックスオプションを有効化すると対応するフィルターが利用可能になりますが、ディスクおよびメモリの使用量がわずかに増加します。

## ベクトル検索

ベクトル検索は、クエリのベクトルと保存済みのベクトルを比較し、最も近い一致を見つける類似度ベースの検索です。

Weaviate は、インポート時およびクエリ時に設定済みの [モデルプロバイダー統合](../../model-providers/index.md) を使用して、テキストや画像などのメディアを統合的にベクトル化します。

### ベクトライザーモデルの選択

ベクトル化とは、ベクトライザーモデルを用いてデータ（テキスト、画像など）を数値ベクトルに変換するプロセスです。

1. **Embedding モデル** : Weaviate は機械学習モデル（例: Transformer）を使用して入力データをベクトル埋め込みに変換します。  
2. **次元数** : ベクトルは通常 768 や 1536 次元など高次元となり、複雑な意味関係を捉えます。  
3. **意味的表現** : 高次元空間におけるベクトルの位置は、他のベクトルとの意味的関係を表します。  

### 近似最近傍 (ANN) 検索

Weaviate のベクトル検索は、ANN アルゴリズムを使用して高次元空間内で類似ベクトルを効率的に検索します。

1. **厳密検索 vs. 近似検索** : 厳密な最近傍検索は最も近いベクトルを保証しますが、計算コストが高くなります。ANN は精度をわずかに犠牲にする代わりに大幅な速度向上を得ます。  
2. **ANN アルゴリズム** : Weaviate は次のような ANN アルゴリズムをサポートします。  
   - HNSW (Hierarchical Navigable Small World): 多層グラフ構造を構築し、高速検索を実現します。  
   - PQ (直積量子化): ベクトルを圧縮してメモリ使用量を削減し、検索速度を向上させます。  
3. **インデックス構築** : データ取り込み時に ANN インデックスを構築し、検索時の高速取得に最適化します。  

### 距離計算指標

ベクトルの類似度は距離計算指標を用いて測定します。Weaviate は複数の指標をサポートします。

1. **コサイン類似度** : ベクトル間の角度のコサインを計算します（多くのユースケースでのデフォルト）。  
2. **ユークリッド距離** : ベクトル間の直線距離を測定します。  
3. **ドット積** : ベクトルのドット積を計算します（正規化された埋め込みの一部で有用）。  

## キーワード検索

### 転置インデックス

Weaviate のキーワード検索は、語を含むドキュメントへのマッピングを行うデータ構造である 転置インデックス に依存しています。

1. **インデックス構築** : データ取り込み時に、Weaviate はテキストをトークンに分割し、それぞれのトークンが含まれるドキュメントをマッピングするインデックスを作成します。  
2. **トークナイズ** : 言語、ステミング、ストップワードなどを考慮しつつテキストを単語またはサブワードに分割します。  
3. **ポスティングリスト** : 各語について、その語を含むドキュメントのリストや語の出現回数などの追加情報を保持します。  

### BM25 アルゴリズム

Weaviate はキーワード検索の結果をランク付けするために BM25F アルゴリズムを使用します。

1. **Term Frequency (TF)** : ある語がドキュメント内で出現する頻度を測定します。  
2. **Inverse Document Frequency (IDF)** : その語が全ドキュメントの中でどれだけ希少か／一般的かを測定します。  
3. **フィールド重み** : BM25F ではドキュメント内のフィールドごとに異なる重みを設定できます。  
4. **スコアリング** : TF、IDF、およびフィールド重みを組み合わせてドキュメントの関連度スコアを算出します。  

## ハイブリッド検索

ハイブリッド検索はベクトル検索とキーワード検索を組み合わせ、両者の長所を活用します。

### 融合手法

Weaviate では、ベクトル検索結果とキーワード検索結果を統合する 2 つの融合手法を提供します。

1. **相対スコア融合** :  
   - ベクトル類似度と BM25 スコアを共通のスケールに正規化します。  
   - 正規化されたスコアを重み付き合計で結合します。  
2. **ランク融合** :  
   - ベクトル検索結果とキーワード検索結果でのオブジェクトの順位に基づいてスコアを付与します。  
   - 順位ベースのスコアを統合し、最終的な並び順を決定します。  

### Alpha パラメーター

Alpha パラメーターはハイブリッド検索におけるベクトル検索とキーワード検索のバランスを制御します。

- Alpha = 0: キーワード検索のみ  
- Alpha = 1: ベクトル検索のみ  
- 0 < Alpha < 1: 両者の重み付き組み合わせ  

## パフォーマンスの考慮事項

1. **インデックス作成** : 高速な検索性能には ANN と 転置インデックス の両方で効率的なインデックスを構築することが重要です。  
2. **シャーディング** : Weaviate は複数のシャードにデータを分散してスケーラビリティを向上できます。  
3. **キャッシュ** : 適切なキャッシュ戦略により、繰り返しまたは類似したクエリの応答時間を大幅に短縮できます。  
4. **ハードウェア** : 特にベクトル演算では GPU アクセラレーションが性能を向上させる場合があります。  
## リランキング

リランキングは、検索結果の関連性を向上させるために、最初に取得した検索結果をより高度なモデルや異なる基準で再順位付けする手法です。

### Cross-Encoder モデル

1. **Bi-Encoder vs. Cross-Encoder** : 初期取得では効率性のために Bi-Encoder モデルがよく使用されますが、リランキングでは通常、より高い精度のために Cross-Encoder モデルが用いられます。  
2. **Attention Mechanism** : Cross-Encoder はクエリとドキュメントのペアを同時に処理し、関連性をより細かく理解できます。  
3. **Computational Trade-off** : Cross-Encoder は計算コストが高いため、最初に取得した結果のうち少量のサブセットに対してのみ使用されます。  


## 関連性の最適化

検索の関連性は次の要素によって影響を受けます。

### ベクトル検索品質

#### ベクトライザー・モデルの選定

ベクトライザー・モデルは、オブジェクトをどのように ベクトル に変換するかを決定します。  
モデルは、テキスト・画像・音声など、データのモダリティに適している必要があります。ドメイン特化モデルの採用や、モデルの複雑さとパフォーマンス要件のバランスを検討してください。  

 Weaviate は ::model provider integrations:: と統合できます。

#### ベクトル化するフィールド

意味理解に最も寄与するフィールドを特定してください。複数のフィールドを 1 つのベクトル埋め込みにまとめることも検討します。構造化データと非構造化データをベクトル化した場合の影響を評価しましょう。

#### ANN インデックス設定


### キーワード検索

- インデックスプロパティの長さ、null プロパティなど  
- これらの設定が検索動作や利用可能なクエリに与える影響  
- k1 と b の値  

### ハイブリッド検索

- ハイブリッド融合方法  
- Alpha 値  


## 検索パフォーマンスとスケーラビリティ

- ベクトルインデックス設定とクエリパフォーマンス  
- 量子化とクエリ  
- 大規模データセットで検索を最適化するためのベストプラクティス  


## 検索拡張生成 ( RAG )

検索拡張生成 ( RAG ) は 生成検索 とも呼ばれ、従来の検索メカニズムと生成系 AI モデルを組み合わせ、取得した情報に基づいて新しいコンテンツを生成します。

### RAG アーキテクチャ

1. **Retriever** :  Weaviate の検索機能（ベクトル、キーワード、またはハイブリッド）を使用して関連情報を取得します。  
2. **Generator** : 取得した情報とユーザーのクエリを基に、大規模言語モデル ( LLM ) を用いて応答を生成します。  
3. **Prompt Engineering** : ユーザーのクエリと取得情報を組み合わせた効果的なプロンプトを設計し、 LLM の出力を誘導します。  

### 言語モデルとの統合

1. **API Connections** :  Weaviate は OpenAI、Cohere、Google など、さまざまな LLM プロバイダーと統合できます。  
2. **Model Selection** : ユーザーは、パフォーマンス、コスト、ユースケースの要件などを考慮して適切なモデルを選択できます。  
3. **Token Management** : トークン上限や切り捨て処理を管理し、 LLM API を効果的に利用します。  

### RAG ワークフロー

1. **Query Processing** : ユーザーのクエリを解析し、検索パラメータを決定します。  
2. **Information Retrieval** :  Weaviate の検索機能を使用して、関連するドキュメントやデータポイントを取得します。  
3. **Context Preparation** : 取得した情報を生成モデルのコンテキストとして準備します。  
4. **Response Generation** : クエリと準備したコンテキストを LLM に送信して応答を生成します。  
5. **Post-processing** : 必要に応じて生成された応答を整形またはフォーマットし、ユーザーへ返します。  


## AI モデルと検索

### 概要

- 検索における AI モデルの役割（ベクトル検索、リランキング、生成検索など）  

### モデル選定ガイド

- 適切なモデルを選択するための基準  
- 異なるモデルタイプ間のトレードオフ  


## 検索関連性とランキング

-  Weaviate が結果の順序を決定する方法  
- 検索関連性を向上させる手法  


## 一般的なユースケース

- EC 商品検索  
- コンテンツ推薦システム  
- セマンティックドキュメント検索  
- 画像・マルチメディア検索  


## トラブルシューティングとよくある落とし穴

- 検索実装でよくある問題への対処  
- 検索に関する問題の診断と解決のヒント  
---
title: リソース計画
sidebar_position: 90
description: "大規模環境で Weaviate のパフォーマンスを最適化するための CPU・メモリ・GPU リソース計画ガイドライン。"
image: og/docs/concepts.jpg
# tags: ['architecture', 'resource', 'cpu', 'memory', 'gpu']
---

Weaviate は大規模プロジェクトでも高いスケーラビリティを発揮します。100 万件未満の小規模プロジェクトであれば特別なリソース計画は不要です。中規模・大規模プロジェクトでは、リソースから最大のパフォーマンスを引き出す計画が必要です。システム設計時には、 CPU とメモリの管理を意識してください。 CPU とメモリが Weaviate インスタンスの主要リソースです。使用するモジュールによっては GPU も重要になります。


## 利用可能リソースの制限

Weaviate のリソース使用量を制御してシステム全体のリソースを使い切らないようにするには、[環境変数](/deploy/configuration/env-vars/index.md)を設定します。利用できる環境変数は次のとおりです。

- `LIMIT_RESOURCES`: `true` に設定すると、Weaviate は自動的にリソース使用量を制限します。メモリ使用量を総メモリの 80% に設定し、 CPU コアは 1 つを除いてすべて使用します。`GOMEMLIMIT` の設定を上書きしますが、`GOMAXPROCS` の設定は尊重します。

- `GOMEMLIMIT`: Go ランタイムのメモリ上限を設定します。Weaviate に割り当てるメモリの総量の 10〜20% 程度に設定してください。メモリ使用量がこの上限に近づくとガベージコレクタの動作が積極的になります。

- `GOMAXPROCS`: 同時実行のために使用する最大スレッド数を設定します。指定すると `LIMIT_RESOURCES` もこの設定を尊重し、Weaviate が使用する CPU コア数を明示的に指定できます。

これらの設定により、システムリソースとバランスを取りながら Weaviate のパフォーマンスを最適化できます。


## CPU の役割

:::tip Rule of thumb
CPU はクエリ速度およびインポート速度に直接影響しますが、データセットサイズには影響しません。
:::

ベクトル検索は Weaviate の操作の中で最も CPU 集約的な処理です。クエリは CPU ボトルネックになりやすく、インポートもインデックス作成時にベクトル検索を行うため CPU ボトルネックになります。Weaviate はベクトルをインデックスするために HNSW (Hierarchical Navigable Small World) アルゴリズムを使用します。主用途に合わせて [HNSW インデックスを調整](../config-refs/indexing/vector-index.mdx) できます。

複数の CPU を効率的に利用するには、コレクションに複数シャードを作成してください。単一ノードでも最速のインポートを実現するには複数シャードを作成します。

各挿入および検索はシングルスレッドで実行されます。ただし、複数の検索や挿入を同時に行う場合、Weaviate はマルチスレッドを利用できます。[バッチ挿入](/weaviate/manage-objects/import)は複数スレッドで並列処理を行います。

### CPU を追加すべきタイミング

インポート時に CPU 使用率が高い場合は CPU を追加してインポート速度を向上させます。

検索スループットが制限されている場合は CPU を追加して 1 秒当たりのクエリ数を増やします。

## メモリの役割

:::tip Rule of thumb
メモリはサポートできる最大データセットサイズを決定します。メモリは直接的にはクエリ速度に影響しません。
:::

HNSW インデックスはメモリ上に保持される必要があります。必要なメモリ量はデータセットサイズに直接比例します。データセットサイズと現在のクエリ負荷には相関がありません。ベクトルを圧縮する [`product quantization (PQ)`](/weaviate/concepts/vector-quantization#product-quantization) を利用すると、メモリに保持できるベクトル数を増やせます。

Weaviate では、予期しない Out-of-Memory（「 OOM 」）を防ぐためにメモリ上に保持するベクトル数の上限を設定できます。デフォルト値はコレクションごとに 1 兆 (`1e12`) オブジェクトです。この値を変更するには、インデックス設定の [`vectorCacheMaxObjects`](../config-refs/indexing/vector-index.mdx) を更新してください。

また、Weaviate はディスク上のデータに対して [メモリマップトファイル](https://en.wikipedia.org/wiki/Memory-mapped_file) を使用します。メモリマップトファイルは効率的ですが、ディスクストレージはメモリより遥かに遅い点に注意してください。

### メモリ使用量を左右する要因

HNSW ベクトルインデックスがメモリ使用量の主因です。以下の要因が影響します。

- **オブジェクトベクトルの総数**  
  ベクトル数が重要であり、元オブジェクトの生データサイズは重要ではありません。メモリに格納されるのはベクトルのみで、元のテキストやその他データのサイズは制限要因になりません。

- **`maxConnections` HNSW インデックス設定**  
  メモリ上の各オブジェクトはレイヤーごとに最大 [`maxConnections`](../config-refs/indexing/vector-index.mdx) 本の接続を持ちます。各接続は 8〜10B のメモリを使用します。ベースレイヤーは `2 * maxConnections` である点に注意してください。

### 計算例

:::note
以下の計算はすべてのベクトルをメモリに保持する前提です。メモリとディスクを組み合わせるハイブリッド方式については後述の [Vector Cache](#vector-cache) を参照してください。
:::

メモリ必要量を概算する経験則は次のとおりです。

`メモリ使用量 = 2 * (全ベクトルのメモリフットプリント)`

例として、384 次元の `float32` 型ベクトルが 100 万件あるモデルを考えます。

- 単一ベクトルのメモリ量は `384 * 4 B = 1536 B`  
- 100 万件のメモリ量は `1e6 * 1536 B = 1.5 GB`

経験則によりメモリ量を 2 倍します。したがって必要メモリは `2 * 1e6 * 1536 B = 3 GB` です。

より正確な計算を行うには、単純に 2 倍する代わりに [`maxConnections`](../config-refs/indexing/vector-index.mdx) の影響を考慮します。

例として `maxConnections` が 64 の場合、より正確な見積もりは  
`1e6 * (1536 B + (64 * 10)) = 2.2 GB` です。

`maxConnections` を含めた見積もりは経験則より小さくなります。ただしこの見積もりにはガベージコレクションによるオーバーヘッドが含まれていません。ガベージコレクションについては次章で説明します。

## ガベージコレクションの影響

Weaviate はガベージコレクションを持つ Go で実装されています。そのため、不要になったメモリが即座に再利用可能になるとは限りません。ガベージコレクタが非同期でメモリを解放する必要があります。これによりメモリ使用に 2 つの影響が出ます。

- [ガベージコレクタのメモリオーバーヘッド](#メモリオーバーヘッド-for-ガベージコレクタ)
- [ガベージコレクションによる OOM 問題](#ガベージコレクションによる-oom-問題)

### メモリオーバーヘッド for ガベージコレクタ
`maxConnections` を含むメモリ計算はシステムが安定した状態を表します。しかし、Weaviate がベクトルをインポートしている間は追加のメモリが割り当てられ、最終的にガベージコレクタが解放します。ガベージコレクションは非同期であるため、この追加メモリも考慮が必要です。前述の「経験則」はこの点を加味しています。

### ガベージコレクションによる OOM 問題
まれに、特に大規模マシンで非常に高速なインポートを行う場合、Weaviate がメモリを割り当てる速度がガベージコレクタが解放する速度を上回ることがあります。この場合、システムカーネルが `out of memory kill (OOM-Kill)` を発動する可能性があります。これは既知の問題であり、Weaviate で改善に取り組んでいます。

### データインポート
インポート中の OOM を避けるには、`LIMIT_RESOURCES` を `True` に設定するか、`GOMEMLIMIT` 環境変数を設定してください。詳細は [環境変数](/deploy/configuration/env-vars/index.md) を参照してください。

## メモリ使用量を削減する戦略

以下の方法で Weaviate のメモリ使用量を削減できます。

- **ベクトル圧縮を使用する**  
  直積量子化 (PQ) はベクトルサイズを縮小する技術です。ベクトル圧縮はリコール性能に影響を与えるため、本番導入前にデータセットでテストすることを推奨します。  
  詳細は [Product Quantization](/weaviate/concepts/vector-quantization) を参照してください。  
  PQ の設定方法は [Compression](../configuration/compression/pq-compression.md) を参照してください。

- **ベクトルの次元数を削減する**  
  メモリサイズを最も効果的に削減する方法は、ベクトルあたりの次元数を減らすことです。高次元ベクトルを使用している場合は、次元の少ないモデルを検討してください。たとえば、384 次元モデルは 1536 次元モデルより遥かにメモリを消費しません。

- **HNSW の [`maxConnections`](../config-refs/indexing/vector-index.mdx) を減らす**  
  メモリ上の各オブジェクトは最大 `maxConnections` 本の接続を持ち、各接続は 8〜10B のメモリを使用します。`maxConnections` を減らすとメモリフットプリントを削減できます。

  `maxConnections` を減らすと HNSW のリコール性能が低下します。これを緩和するために `efConstruction` と `ef` のいずれか、または両方を増やしてください。

  - `efConstruction` を増やすとインポート時間が増え、クエリ時間には影響しません。  
  - `ef` を増やすとクエリ時間が増え、インポート時間には影響しません。

- **全ベクトル数より小さいベクトルキャッシュを使用する（非推奨）**  
  この戦略は後述の [Vector Cache](#vector-cache) で説明します。パフォーマンスに大きな影響があるため、限定的な状況でのみ推奨されます。

## Vector Cache

検索およびインポートを最適化するには、インポート済みのベクトルをすべてメモリに保持する必要があります。ベクトルキャッシュのサイズは、コレクション定義の [`vectorCacheMaxObjects`](../config-refs/indexing/vector-index.mdx) パラメータで指定します。新規コレクションではデフォルトで 1 兆 (`1e12`) オブジェクトに設定されています。

`vectorCacheMaxObjects` を小さく設定することもできますが、ディスクからのベクトル取得はメモリ取得より何桁も遅くなります。`vectorCacheMaxObjects` を減らす場合は十分注意し、最後の手段としてのみ行ってください。

一般的な推奨事項は次のとおりです。
- インポート中は `vectorCacheMaxObjects` をすべてのベクトルをメモリに保持できる値に設定してください。インポートでは複数回の検索が行われ、キャッシュに全ベクトルがないとインポート性能が大幅に低下します。

- インポート後にクエリ中心のワークロードになる場合は、データセット総量より小さいキャッシュサイズを試してください。

  キャッシュに存在しないベクトルは空きがあればキャッシュに追加されます。キャッシュが満杯になると、Weaviate はキャッシュ全体を破棄します。その後、すべてのベクトルが初回はディスクから読み込まれ、再びキャッシュが満杯になるまでキャッシュが使用されます。  
  大規模データセットで多くのユーザーが特定のベクトル集合のみを検索するケースでは、キャッシュが非常に有効です。大多数のユーザーはキャッシュから、高頻度でないクエリはディスク読み込みで対応できます。
### Weaviate マシンまたはクラスターのメモリ増設タイミング

メモリを追加するべきケース:  
- より大きなデータセットをインポートしたい場合（より一般的）。  
- 正確検索 ( exact lookups ) がディスク依存になっており、メモリを増やすことでページキャッシュ ( page-caching ) を改善できる場合（あまり一般的ではありません）。

## Weaviate における GPU の役割

Weaviate Database 自体は GPU を使用しません。 しかし、Weaviate がモジュールとして提供するモデルの中には GPU での実行を想定しているものがあります。 例えば `text2vec-transformers`、`qna-transformers`、`ner-transformers` などです。 これらのモジュールは分離されたコンテナ内で動作するため、モジュールのコンテナを GPU アクセラレートされたハードウェア上で実行しつつ、Weaviate Database を低コストの CPU のみのハードウェアで実行できます。

## ディスク: SSD と HDD ( Spinning Disk ) の比較

Weaviate は Solid-State Disk ( SSD ) での利用に最適化されています。 ただし、回転式ハードディスク ( HDD ) でも、ある程度の性能低下を受け入れれば使用可能です。

## ファイルシステム

最適な性能と信頼性を確保するため、Weaviate の永続ボリューム ( [`PERSISTENCE_DATA_PATH`](/deploy/configuration/env-vars/index.md) ) には NFS などのファイルシステムを使用しないでください。

代わりに、Ext4 や XFS といったファイルシステムを SAN ストレージ ( 例: EBS ) と組み合わせて使用することで、最高のパフォーマンスを得られます。

## 質問とフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>
---
title: ストレージ
sidebar_position: 18
description: "オブジェクト、 ベクトル、 転置インデックス管理のための永続的で障害耐性のあるストレージアーキテクチャ。"
image: og/docs/concepts.jpg
# tags: ['architecture', 'storage']
---

Weaviate は永続的で障害耐性のあるデータベースです。  
このページでは、 Weaviate 内でオブジェクトとベクトルがどのように保存され、インポート時に転置インデックスがどのように作成されるかを概観します。

ここで取り上げるコンポーネントは、 Weaviate が以下のような独自機能を実現するのに役立っています。

* 各書き込み操作は即座に永続化され、アプリケーションやシステムのクラッシュにも耐性があります。  
* ベクトル検索クエリでは、 Weaviate は ID などの参照だけでなくオブジェクト全体（他のデータベースでは「ドキュメント」と呼ばれることもあります）を返します。  
* 構造化検索とベクトル検索を組み合わせる場合、フィルターはベクトル検索の前に適用されます。これにより、後段でフィルタリングして結果数が予測できなくなるのではなく、常に指定した件数を取得できます。  
* オブジェクトとそのベクトルは、読み取り中であっても自由に更新・削除できます。

## 論理ストレージ単位: インデックス、シャード、ストア

ユーザー定義スキーマ内の各クラスは、内部的にはインデックスの作成につながります。  
インデックスは 1 つ以上のシャードで構成されるラッパー型です。シャードは自己完結型のストレージ単位であり、複数シャードを利用すると負荷を複数サーバーノードへ自動的に分散できます。

### シャードの構成要素

各シャードには 3 つの主要コンポーネントがあります。

* オブジェクトストア (実質的にはキー・バリュー ストア)  
* [転置インデックス](https://en.wikipedia.org/wiki/Inverted_index)  
* ベクトルインデックスストア (プラガブルで、現在は [HNSW のカスタム実装](/weaviate/config-refs/indexing/vector-index.mdx#hnsw-index))

#### オブジェクトストアと転置インデックスストア

`v1.5.0` 以降、オブジェクトストアと転置ストアは [LSM-Tree アプローチ](https://en.wikipedia.org/wiki/Log-structured_merge-tree) を採用しています。  
これにより、データはメモリ速度で取り込まれ、設定したしきい値に達すると Weaviate はメモリテーブル (memtable) 全体をソートした状態でディスクセグメントに書き込みます。読み取り要求が来ると、 Weaviate はまず memtable を確認し、対象オブジェクトの最新更新を探します。 memtable にない場合は、最新のセグメントから順に確認します。不要なセグメントを調べないようにするため、 [Bloom フィルター](https://en.wikipedia.org/wiki/Bloom_filter) を使用します。

Weaviate は定期的に古い小さなセグメントをマージして大きなセグメントを作成します。セグメントはすでにソートされているため、この操作は比較的低コストで、常にバックグラウンドで実行されます。セグメント数が少なく大きくなることで検索効率が向上します。転置インデックスではデータが置き換わることはほとんどなく、追加が主です。マージにより、過去の複数セグメントを走査して結果を集約するのではなく、 1 つ (または少数) のセグメントを参照するだけで関連オブジェクトポインタを即座に見つけられます。また、削除や更新によって古くなったオブジェクトの以前のバージョンをセグメントから除去できます。

考慮事項

* オブジェクトストレージと転置インデックスストレージは LSM アルゴリズムを実装しており、セグメンテーションを採用します。  
* ベクトルインデックスは異なるストレージアルゴリズムを用い、セグメンテーションを行いません。  

`v1.5.0` より前の Weaviate バージョンでは B+Tree ストレージ機構を使用していました。 LSM 方式は高速で、時間計算量が一定となり、書き込み性能が向上します。

Weaviate の LSM ストアについて詳しくは、 [Go パッケージリポジトリ](https://pkg.go.dev/github.com/weaviate/weaviate/adapters/repos/db/lsmkv) のドキュメントをご覧ください。

#### HNSW ベクトルインデックスストレージ

各シャードには、オブジェクトストアおよび転置インデックスストアに対応するベクトルインデックスが含まれます。ベクトルストアと他のストアは独立しており、ベクトルストアはセグメンテーションを管理する必要がありません。

ベクトルインデックスをオブジェクトストレージと同じシャードにまとめることで、各シャードを独立してリクエストを処理できる完全なユニットにできます。また、ベクトルインデックスをオブジェクトストアの「隣」に配置し (内部に入れず)、ベクトルインデックスをセグメント化することによるデメリットを回避しています。

さらに、 [永続化とクラッシュリカバリ](#persistence-and-crash-recovery) で詳述する Write-Ahead-Logging と HNSW スナップショットを組み合わせることで、永続化と起動時のロードを最適化しています。

### シャード構成要素の最適化

Weaviate のストレージ機構は、構造化／オブジェクトデータに対してセグメンテーションを使用します。セグメントは低コストでマージでき、 Bloom フィルターのおかげで未マージのセグメントでも効率的に走査できます。その結果、取り込み速度は高く、時間が経っても低下しません。

Weaviate はシャード内のベクトルインデックスを可能な限り大きく保ちます。 HNSW インデックスは効率的にマージできないため、小さいインデックスを多数順番に検索するより、 1 つの大きなインデックスを検索する方が効率的です。

CPU を効率良く使うには、コレクションに複数シャードを作成してください。最速でインポートしたい場合は、単一ノードでも複数シャードを作成することを推奨します。

### レイジーシャードロード

:::info Added in `v1.23`
:::

Weaviate 起動時には、デプロイ内のすべてのシャードからデータをロードします。このプロセスは時間がかかる場合があります。 `v1.23` 以前は、すべてのシャードがロード完了するまでデータをクエリできませんでした。各テナントが 1 シャードであるため、マルチテナント環境では再起動後の可用性が低下する可能性があります。

レイジーシャードロードにより、より早くデータにアクセスできます。再起動後、シャードはバックグラウンドでロードされます。クエリしたいシャードがすでにロード済みであれば、すぐに結果を取得できます。未ロードの場合、 Weaviate はそのシャードのロードを優先し、準備完了後にレスポンスを返します。

レイジーシャードロードを有効にするには、システム設定ファイルで `DISABLE_LAZY_LOAD_SHARDS` 環境変数を `false` に設定してください。

:::caution シングルテナントコレクションでは無効化を推奨
シングルテナントコレクションでは、レイジーシャードロードがインポート操作を遅延または部分的失敗させる場合があります。そのようなシナリオでは、レイジーシャードロードを無効化することを推奨します。
:::

## 永続化とクラッシュリカバリ

### Write-Ahead-Log

オブジェクトおよび転置ストレージで使用する LSM ストアと、 HNSW ベクトルインデックスストアは、取り込み処理の途中でメモリを利用します。クラッシュ時のデータ損失を防ぐため、各操作は **[Write-Ahead-Log (WAL)](https://martinfowler.com/articles/patterns-of-distributed-systems/wal.html)** (コミットログとも呼ばれます) に追加で書き込まれます。 WAL は追記専用ファイルで書き込みが非常に高速であり、取り込みのボトルネックになることはほとんどありません。

Weaviate が取り込みリクエストへ成功ステータスを返す時点で、 WAL エントリは必ず作成されています。たとえばディスクが満杯で WAL エントリを作成できない場合、 Weaviate は挿入または更新リクエストにエラーで応答します。

LSM ストアは正常終了時にセグメントのフラッシュを試みます。操作が成功した場合のみ、 WAL は「完了」とマークされます。予期しないクラッシュが発生し Weaviate が「未完了」の WAL を検出した場合、これをリカバリします。リカバリプロセスでは、 WAL を基に新しいセグメントをフラッシュし、完了としてマークします。そのため、次回起動時にはこの WAL から復旧する必要がなくなります。

HNSW ベクトルインデックスにおいて、 Write-Ahead-Log (WAL) は災害復旧と最新変更の永続化に不可欠です。 HNSW インデックス構築のコストは、新規オブジェクトをどこに配置し隣接ノードとどうリンクするかを決定する計算にあります。 WAL にはその計算結果のみが格納されます。

WAL エントリをリプレイすることで、 HNSW インデックスの全状態を再構成できます。

数千万～数億規模の大規模インデックスでは、これは時間を要する場合があります。大規模インデックスで起動時間を短縮したい場合は、 **[HNSW スナップショット](../configuration/hnsw-snapshots.md)** 機能をご利用ください。

### HNSW スナップショット

:::info Added in `v1.31`
:::

巨大な HNSW ベクトルインデックスを持つ場合、 HNSW スナップショットによって起動時間を大幅に短縮できます。

スナップショットは HNSW インデックスの時点状態を表します。 Weaviate 起動時に有効なスナップショットが存在すれば、まずそれをメモリにロードします。これにより、 WAL からリプレイすべきエントリ数がスナップショット取得後の変更分だけに減り、起動が高速化されます。

スナップショットが何らかの理由でロードできない場合、安全に削除され、 Weaviate は従来通りコミットログ全体の読み込みへフォールバックします。

スナップショットは起動時と、経過時間またはコミットログの変化量に基づき定期的に作成されます。

起動時に前回スナップショット以降のコミットログに変更があれば、新しいスナップショットを作成します。変更がなければ既存スナップショットをロードします。

設定した時間間隔が経過し、十分な新規コミットが存在する場合にもスナップショットを作成します。これはコミットログの結合・圧縮を行うバックグラウンドプロセスと同じプロセスが担当し、スナップショット作成中に使用するコミットログは不変であるため安定性が保たれます。

各新規 HNSW スナップショットは、前回スナップショットとそれ以降の新しい (デルタ) コミットログを基に作成されます。

最新スナップショットがあっても、サーバーは通常少なくとも 1 つのそれ以降のコミットログをロードする必要があります。

WAL は依然としてすべての変更を即座に永続化し、応答済みの書き込みが失われないことを保証します。時間が経つと、最後のスナップショット以降の操作に関して WAL には冗長情報が蓄積します。バックグラウンドプロセスがこれらの WAL を継続的にコンパクトし、冗長情報を排除します。これとスナップショットにより、ディスク使用量を抑えつつ起動時間を高速に保ちます。

この機能の詳細設定は **[HNSW スナップショットの設定](../configuration/hnsw-snapshots.md)** をご覧ください。

`v1.31` 現在、 HNSW スナップショットはデフォルトで無効です。

## まとめ

本ページでは Weaviate のストレージ機構を紹介しました。すべての書き込みが即時永続化されるしくみと、データセットをスケールさせるために Weaviate が用いているパターンを説明しました。構造化データではセグメンテーションを用いて書き込み時間を一定に保ち、 HNSW ベクトルインデックスではセグメンテーションを避けることでクエリ時間を効率化しています。
## 質問とフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>